# 毕设文本内容

## 第1章、绪论

### 1.1、研究背景与意义

​		“互联网+”的概念在2012年首次被提出，发展至今，互联网已经覆盖了我们生活的多个方面，使用互联网，给我们的生活带来了许多便利【12】。而互联网的高速发展，也在带动着中国经济的快速发展。“互联网+”的概念，是指互联网思维与技术在传统产业基础上的结合，为传统行业带来新的活力，注入新的动力。教育作为一个传统行业，与互联网结合后的在线学习的概念也在迅速发展。在线学习不受时间、地理等因素的限制，降低了学习成本和门槛，提供了一种全新的学习方式【13】，用户可以将高质量的自定义课程发布到在线平台，供其他人随时随地学习。由于互联网技术的快速发展，如今的人们不必出门即可获取有趣的课程学习资源，同时，互联网允许我们定向地提出自己的问题，请求他人的回答，学习的广度获得极大的扩展。

​		为了加入“互联网+”的浪潮，许多互联网教育产品出现在网络上，大多是基于单体架构的实现，而这种结构不利于业务量较大的项目的开发和维护，随着业务的增长，单体服务的代码会变得越来越大，导致整个系统变得非常复杂，不仅增加了开发人员后续的理解和维护难度，也降低了系统的可维护性和可扩展性。另外，在单体服务架构中，所有的功能模块都紧密耦合在一起，这导致在开发新功能或修改现有功能时，需要考虑到整个系统的稳定性和兼容性，从而降低了开发速度。因此，系统采用微服务架构进行开发，整个应用被拆分为多个独立的服务，每个服务都可以独立开发、部署和扩展，相较于单体服务架构，具有更高的灵活性、可伸缩性和可靠性【14】。同时，微服务架构下应用可以方便地实现服务的弹性伸缩。根据系统的负载情况，可以动态地增加或减少服务实例的数量，从而确保系统始终运行在最佳状态。

​		目前，国内许多在线学习社区网站都关注于平台本身开设的课程并从中获利，虽然处于商业化的考量情有可原，但是这并不能让大多数人共同享受到互联网对学习教育的促进和便利。同时，大多社区的功能较为单一，而用户往往有一系列功能需求，这使得用户需要在多个应用之间切换，带来了使用上的不便。此外，绝大多数教育平台对第三方的支持并不友好，不具备对外提供服务的能力，想要基于丰富的教育资源和用户数据进行多终端开发不便利，没有对资源实现充分利用。因此，本文提出基于微服务架构来设计在线教育社区平台，可以为同学们提供知识共享、在线答疑、在线社交等一系列功能，一站式解决同学们学习过程中的获取知识、分享知识、解答问题、交流讨论的需求，并且通过设计网关鉴权系统，对外API开放，让系统拥有对外提供服务的能力。基于微服务架构，搭建开放API平台，打造一个有吸引力、拓展性强、高性能、第三方开放友好的在线学习社区。



### 1.2、国内外研究现状

#### 1.2.1、国外研究现状

​		在国外，在线学习非常流行，美国的在线学习的覆盖率在世界上排名第一，在线学习和知识获取的模式在美国已经趋于稳定【15】【16】。自从2012年以来，MOOC在世界各地变得流行起来，并且被大众广泛接受【17】。除MOOC之外，美国还有非盈利教育学习机构Khan academy，其与MOOC不同的地方在于，Khan academy的用户可以上传自己录制的视频课程，然后提供给其它用户学习【18】。除了课程的学习，还有针对特定领域的知识交流社区，例如StackOverflow。StackOverflow是一个与程序相关的IT技术问答网站。用户可以在网站上提问，寻求解答，也可以浏览其他用户提出的问题和答案，从而获取知识和经验。Stack Overflow的特点在于其严谨的问答机制。它要求提问者必须清晰地阐述问题，提供足够的背景信息，以便其他用户能够理解并回答。同时，答案也需要经过严格的审核和筛选，确保其准确性和可靠性。这种机制使得Stack Overflow上的内容质量非常高，得到了广大程序员的信任和认可。

​		为了满足业务需求的不断增加，网站的架构也从最初的单体架构转成垂直架构，最后再到现在流行的分布式架构【19】。将单体架构的应用根据业务需求拆分为不同的微服务模块，各模块之间采用轻量级传输协议来交互【20】。NetFlix公司最早研发并开源了微服务架构，随后其它公司例如Amazon、Twitter等也推出自己的微服务组件，并被整合到了SpringCloud项目中【21】。



#### 1.2.2、国内研究现状

​		在国内，在线学习的发展势头强劲【22】。随着国内互联网的蓬勃发展，国内的在线学习平台也在不断发展，基本上实现了全年龄段的教育课程覆盖【23】。比较知名的在线学习平台有网易公开课、腾讯课堂和中国大学MOOC网等。网易公开课主要通过联合机构和个人来提供视频资料，腾讯课堂主要以视频直播的形式进行教学，而中国大学MOOC网与MOOC类似，以各高校的视频学习资料为主来进行在线学习。而在特点的技术垂直领域，则有分享社区CSDN，CSDN是一个专业的中文IT技术社区，致力于为中国软件开发者提供知识传播、在线学习、职业发展等全生命周期服务。它涵盖了技术文章、开发资源和在线交流渠道，为开发者之间的沟通和学习搭建了平台。在线学习意味着学习不再局限于时间和空间，任何人都可以利用碎片时间在互联网上随时随地进行学习，未来的发展前景非常广阔【24】。

​		微服务架构在国内同样有着广泛的运用。Dubbo是国内实际比较多的一种分布式服务框架，不过Dubbo后期停止了一段时间的维护，热度有所下降。而后阿里巴巴将自己的微服务技术融入了SpringCloud体系，形成了SpringCloudAlibaba的结构体系，包括一系列阿里开源的服务注册，熔断限流等组件【25】。大众点评、携程等其它互联网公司也都有自己的开源微服务组件，在开源社区和各大互联网公司的共同参与下，形成了以国内开源技术为核心的微服务技术体系。



### 1.3、本文主要研究工作

​		本文将紧紧围绕在线教育学习的知识获取、知识分享、解答问题、在线社交等全链路需求，针对当前业界主要产品和教学实践过程中存在的痛点，例如提供的功能过于单一，互动性较低等问题，结合微服务架构特点设计开发一个高并发、高可用的在线教育社区。该系统不仅能涵盖用户的一系列知识学习分享的需求，而且通过使用分布式架构和基于SpringCloudAlibaba的分布式解决方案，使得系统支持高并发请求，具备容错性、高可用性和易扩展性。此外，基于对SpringCloudGateway网关鉴权功能的改造，实现第三方开发者的租户入驻，完成鉴权的第三方系统可以调用平台现有API进行前端定制化开发，使得系统具有强大的对外提供服务的能力。采用Docker容器技术运行和部署节约磁盘空间。

​		本文研究内容主要分为以下几个方面：

​		（1）：对在线教育社区的主要微服务模块进行明确的功能性需求分析，对系统提出界面需求和性能提升需求，在功能模块设计和代码编写上满足高内聚、低耦合、扩展性强的要求，在系统架构设计和技术选型上考虑性能的提升，为后续系统二次开发和优化预留足够的空间。

​		（2）：设计第三方接口开放鉴权规则，结合Swagger提供详细的Restful接口文档。

​		（3）：采用微服务的系统架构设计【26】，融入SpringCloudAlibaba分布式解决方案【27】。前端采用Vue框架。通过拆解系统业务逻辑，将系统功能划分为系统核心服务、认证中心服务、定时任务服务、内容服务、通知服务、外部API接入服务、文件服务、消息队列消费者服务。使用Nacos作为注册中心，协调各个微服务。

​		（4）：在数据持久化上，使用MySQL作为关系型业务数据库，不同微服务采用不同的数据库，提高数据库的访问性能和可用性。对于实时性要求比较高、数据量比较大的文本内容查询，使用Elasticsearch搜索引擎，根据关键字进行全局模糊查询；对于并发量高、访问量大的数据，使用Redis作为分布式缓存处理【28】。

​		（5）：使用容器化技术，采用Docker平台部署微服务和组件以及集群模式的搭建，提升搭建的便捷性和可控性，实现应用的“一键部署”。





### 1.4、本文的组织结构

​		本文的章节安排如下：

​		第1章为绪论部分，依次介绍本研究的背景与意义、国内外研究现状和本文的主要工作。

​		第2章对系统中使用到的相关技术理论进行介绍，包括SpringBoot与SpringCloud、Redis、RocketMQ消息中间件、Docker和Elasticsearch搜索引擎。

​		 第3章为系统需求分析，根据功能性需求和非功能性需求，将系统拆分为8个微服务，划分每个微服务的功能以及职责边界。服务分别为四个业务性微服务：内容服务、通知服务、外部API接入服务、消费者服务，以及四个系统性微服务：系统核心服务、认证中心服务、定时任务服务、文件服务。

​		第4章为教育社区系统设计和实现部分，首先从宏观上阐述了系统设计目标和系统总架构，然后对系统各个服务模块以及各个需求点进行详细设计，最后介绍了关系型数据表的表结构设计；阐述了系统的分层架构的实现和环境的配置，以及各个微服务的主要功能实现过程。

​		第5章为系统测试部分，对系统的测试环境、Docker组件环境进行了说明，对服务的主要功能进行功能测试，使用JMeter性能测试工具、Nacos服务监控工具对系统进行非功能性测试。

​		第6章对工作进行总结与展望，总结了论文的研究工作以及对未来进一步研究和开发的展望。



## 第2章、 相关技术理论

### 2.1、Java技术

​		Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

​		Java的发展历史可以追溯到上世纪90年代初。1991年，Sun公司（Stanford University Network）的Green项目小组，以加拿大人James Gosling为首，开始开发一种名为Oak的计算机语言，旨在用于消费类电子产品市场，实现平台独立性的目标。这种语言的设计初衷是使其能在任何软件平台上运行。

​		进入21世纪后，Java继续发展壮大。2004年，J2SE 5.0（Tiger）发布，这是Java的一个重要版本，为了强调其重要性，J2SE 1.5的命名方式被更改为J2SE 5.0。随后，2006年，J2SE 6.0（Mustang）发布，为Java引入了更多的新特性和优化。

​		Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。【1】

​		Java广泛应用于企业级Web应用开发和移动应用开发，是全球最受欢迎的编程语言之一。许多知名的大型网站都是用Java开发的，如淘宝、京东、阿里巴巴等。

​		Java分为三个体系，分别为Java SE（Java Platform，Standard Edition，Java平台标准版），Java EE（Java Platform，Enterprise Edition，Java平台企业版），Java ME（Java Platform，Micro Edition，Java平台微型版）。

​		当前国内的IT市场，超过90%的服务端建设，使用的是Java。



### 2.2、SpringBoot框架

​		SpringBoot是一个由Pivotal团队提供的全新框架，它专注于简化Spring应用的初始搭建和开发过程【3】。通过SpringBoot，开发人员能够更快速、更高效地创建出具备基本功能的Spring应用程序。

​		Spring Boot 简化了 Spring 项目在开发中复杂的配置文件【2】，通过使用 Starter 模块来定义需要去引用的系统需要使用的功能，这有助于让系统管理变得更加简洁便利【4】，同时，SpringBoot 提供了丰富的开箱即用工具，通过引入自动依赖的方式，开发者能够快速构建项目，减少了繁琐的配置过程【5】。

​		SpringBoot的核心特性包括：

1. **简化的配置**：SpringBoot采用了约定优于配置的方式，通过自动化配置和默认设置，大大减少了开发人员需要手动进行的配置工作。这使得开发者能够更专注于业务逻辑的实现，而不是繁琐的配置细节。
2. **内嵌Web容器**：SpringBoot内置了多种常用的Web容器，如Tomcat、Jetty等，使得构建独立的Web应用程序变得简单直接。开发人员无需再单独配置和部署Web服务器，只需将应用程序打包成可执行的JAR或WAR文件，即可直接运行。
3. **自动化依赖管理**：SpringBoot通过提供一系列的“starter”依赖，自动管理应用程序的依赖关系。这使得依赖管理变得简单明了，减少了手动添加和管理依赖的复杂性。
4. **丰富的开发者工具**：SpringBoot为开发者提供了一系列实用的工具，如热部署、自动重启和自动配置报告等。这些工具能够帮助开发者更高效地开发、测试和调试应用程序。
5. **外部化配置**：SpringBoot支持使用外部配置文件（如YAML或properties文件）来配置应用程序的属性。这使得配置更加灵活和可管理，方便开发者根据不同环境或需求进行调整。

​		总的来说，SpringBoot是一个功能强大且易于使用的框架，它通过简化配置、自动化管理、提供丰富的开发者工具以及外部化配置等特性，为开发人员创建高效、可靠的Spring应用程序提供了有力的支持。

![图2-1 SpringBoot流程架构图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\1.jpg)



### 2.3、微服务架构与SpringCloud

​		微服务架构是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。具体来说，它将一个大型的单个应用程序和服务拆分为数个甚至数十个支持微服务，这些微服务围绕业务领域组件来创建应用，可独立地进行开发、管理和迭代。这种架构方式使得每个服务只关注一个业务功能，从而降低了系统的耦合性，提供了更加灵活的服务支持。【6】

​		微服务的划分方式更加精细化，这确保了系统的部署速度更为迅捷，同时也大幅提升了其可扩展性，使整个系统更加稳健可靠。相较于单体架构，在微服务架构中，开发人员仅需针对特定子服务进行代码修改，并重新部署这些子服务【9】，而无需对整个系统进行重新部署。这种方式不仅显著节约了系统资源，还有效降低了维护部署的成本。更重要的是，微服务的思想有助于避免整个系统因某一子服务的故障而崩溃，从而确保了系统的持续稳定运行。【7】

​		目前主流的并且提供落地方案的微服务架构主要有Spring Cloud和SpringCloudAlibaba。

​		SpringCloud是一系列框架的有序集合【8】，它利用Spring Boot的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。SpringCloud的理念是解决在微服务架构中遇到的任何问题，通过Spring Boot风格进行再封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

​		SpringCloudAlibaba则是第二代分布式微服务架构，属于SpringCloud的拓展，它包含了开发分布式应用微服务的必需组件，方便开发者轻松使用这些组件来开发分布式应用服务。与SpringCloud相比，SpringCloudAlibaba更注重推广阿里的产品，如果使用了SpringCloudAlibaba，最好使用alibaba整个体系产品。其中，Nacos是阿里开源的一个组件，它提供了动态服务发现、配置管理和服务管理平台的功能，相当于Eureka和Config的组合。

![图2-2 SpringCloudAlibaba架构图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\2.jpg)



### 2.4、Redis缓存技术

​		Redis，即远程字典服务（Remote Dictionary Server），是一个开源的、使用ANSI C语言编写的、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。Redis把数据存储在内存中，使得数据读写速度非常快，但同时也意味着如果系统重启或进程退出，内存中的数据会丢失。因此，Redis还提供了持久化功能，通过把数据存储在硬盘上，对内存上的数据进行备份，确保在系统重启后能够恢复到之前的状态。Redis 还内置了复制和 Lua 脚本功能，可以通过主从模式对数据进行备份。【10】

​		Redis的主要应用场景之一是作为缓存/数据库缓存，用于加速API性能。例如，在WebServer和数据库之间增加一层Redis缓存，可以使WebServer直接从Redis中快速获取数据并返回，从而提高WebServer的响应速度。在电商领域，Redis可以缓存热门商品的静态信息或用户数据，以应对大流量访问，加速访问速度。此外，Redis还支持集群，可以进一步提高数据处理能力和稳定性。

​		在使用Redis时，可以通过配置实现不同的功能。例如，可以配置Redis是否以守护进程方式启动，设置Redis绑定的网络接口，以及进行各种持久化配置等。此外，Redis还提供了丰富的API和工具，方便开发者进行管理和监控。

​		总的来说，Redis是一个功能强大、性能卓越的Key-Value数据库，适用于各种需要快速读写和缓存数据的场景。

![图2-3 Redis架构图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\3.jpg)



### 2.5、MySQL数据库

​		MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，现在属于Oracle旗下产品。它是当前最流行的关系型数据库管理系统之一，特别是在WEB应用方面，MySQL是最好的RDBMS（Relational Database Management System，关系数据库管理系统）应用软件之一。

​		MySQL使用了关系数据库的设计，即将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这种方式增加了速度并提高了灵活性。MySQL使用的SQL语言是用于访问数据库的最常用标准化语言。

​		MySQL在性能和可扩展性方面非常出色。它使用了一种名为MyISAM的独特存储引擎，这种引擎具有高性能、高并发的特点。同时，MySQL还支持InnoDB存储引擎，它提供了更好的事务处理和并发控制功能。这使得MySQL能够轻松处理大量数据，而不会影响性能。

​		Mysql 软件的授权分为社区版和商业版，由于社区版的 Mysql 在性能上就较为卓越， 很多企业选择使用 Mysql+PHP 或者 Mysql+Apache 进行开发环境的搭建，虽然没有 Oracle、SQL Server 等大型数据库功能多，Mysql 在一般的开发使用上已经绰绰有余， 在成本节约上也有优势。



### 2.6、消息中间件

​		消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。消息中间件的主要特点包括分布式、可靠性、异步、松耦合以及事件驱动。在分布式系统中，消息中间件可以屏蔽各种平台及协议之间的特性差异，实现应用程序之间的协同工作。

​		消息中间件被广泛应用于各种场景中，如异步处理、流量削峰、应用解耦以及消息通讯等。通过消息中间件，可以将一些不需要立即响应的任务转化为消息进行异步处理，提高系统的吞吐量。同时，它还可以缓冲大量的请求，避免系统在高并发场景下因瞬间流量过大而崩溃。

​		当前市场下，占据主流的消息中间件有三种，分别是：RabbitMQ、Kafka、RocketMQ。

​		RabbitMQ支持AMQP协议，提供灵活的消息路由机制，并具备出色的集群扩展能力。RabbitMQ适用于构建解耦、异步处理的分布式系统，确保消息的可靠传递和系统的稳定运行。与其他中间件相比，RabbitMQ在消息路由和可靠性方面表现出色，但可能在处理超大规模数据方面稍显逊色。

​		Kafka是一个专为大数据和实时流处理而设计的分布式发布订阅消息系统。它以其高吞吐量和分布式架构著称，能够轻松应对海量数据的处理需求。Kafka适用于日志收集、事件驱动等大规模数据处理场景，通过持久化机制确保数据的高可靠性。与RabbitMQ相比，Kafka更侧重于大规模数据的实时处理，但在消息路由和灵活性方面可能稍逊一筹。

​		RocketMQ以其低延迟和高可靠性在消息中间件领域受到青睐。它提供多种消息发送方式，并支持消息顺序、消息过滤等高级功能，满足复杂业务场景的需求。RocketMQ的高性能和易扩展性使其成为构建大规模分布式系统的理想选择。与Kafka相比，RocketMQ在消息处理方面可能更加灵活和细致，但在处理超大规模数据方面可能稍逊于Kafka。

​		本项目中，出于对丰富的功能特性，如消息顺序、消息过滤、消息重试等，满足了复杂业务场景的需求、灵活的消息发送方式和高可靠性的需求，选择使用RocketMQ。

![图2-4 RocketMQ架构图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\4.jpg)



### 2.7、Docker容器化技术

​		容器化技术是一种虚拟化技术，其目的在于快速对应用进行标准化部署。这种技术使得应用能够在隔离的环境中运行，彼此之间互不干扰，从而提高了应用的可靠性和安全性。

​		我们在进行开发环境和生产环境部署时，常常需要安装一系列其它依赖的组件，例如数据库、缓存、控制面板等，每种依赖又有各自的依赖项，项目规模一大便会难以维护，而安装后的管理也是一件麻烦的事情，此时我们便希望将每个组件打包，而容器化技术解决了这一难题，允许我们将各个组件一键部署，甚至是一键部署一系列应用。容器化技术通过约束和修改进程的动态表现，为其创造出一个“边界”，确保每个应用都在其自己的容器内运行，实现了应用之间的隔离。这种隔离性是通过Cgroups技术和Namespace技术来实现的，其中Cgroups技术用来制造约束，而Namespace技术则是用来修改进程视图。

​		Docker是一个开源的应用容器引擎，它利用Linux内核的命名空间和控制组等特性，提供了一个简单易用的容器运行时环境。通过Docker，开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows操作系统的机器上。Docker的优势在于其庞大的生态系统和丰富的工具链，例如Docker Hub是集中存储和共享Docker镜像的平台，而Docker Compose、Docker Swarm和Kubernetes等工具则用于实现容器的编排和集群管理。

​		本项目中，开发环境和微服务应用都是通过容器化进行部署。



### 2.8、Elasticsearch搜索引擎

​		在互联网应用中，搜索是一个常见的功能，然后在超大规模数据量下的全量模糊查询，对于传统关系型数据库来说，性能很差，业务上不可接受。因此通常由另外的分布式组件进行处理，兼容传统关系型数据库的OLAP分析性数据库是一种解决方案，而对于非结构化数据，例如JSON、文件等，业界主流的方案是通过Elasticsearch进行搜索。

​		Elasticsearch是一个开源的分布式搜索和分析引擎，它位于Elastic Stack的核心，被广泛应用于构建实时的、可扩展的搜索和分析应用程序。Elasticsearch的主要作用是存储、搜索和分析大量的数据，无论这些数据是结构化、非结构化文本、数字数据还是地理空间数据。

​		Elasticsearch包含许多优秀特性，如实时搜索数据、易于扩展、天生集群、高容错性和稳定性、开箱即用等。在Elasticsearch中，每个文档有唯一 ID，并按类型分组。索引可以包含一个或多个类型，这使得 Elasticsearch 具有高度的灵活性和可扩展性。【11】

​		Elasticsearch采用了Lucene的倒排索引结构，为每个字段构建了独立的索引。这一倒排索引主要由全文中的不重复词汇构成，且采用B-Tree排序方式，以分词索引树的形式进行存储。

​		不仅如此，Elasticsearch还能与Kibana、Logstash等工具无缝整合，形成强大的ELK日志分析解决方案，广泛应用于实时监控、数据分析、数据可视化及数据仪表盘等多个领域。

​		除了搜索领域，Elasticsearch的应用场景十分广泛。它可以作为数据存储和查询引擎，处理结构化数据，并利用其强大的查询语言进行高效检索。同时，它还能作为日志分析引擎，实时收集和分析日志数据。此外，Elasticsearch在网络流量监控、在线推荐和个性化推荐等领域也发挥着重要作用。

​		综上所述，Elasticsearch不仅是一个功能强大的全文搜索引擎，具备高性能、高可用、易扩展、实时搜索和聚合功能等特点，还在多个领域有着广泛的应用。同时，它具备开箱即用和易于集成的优势，能够轻松与其他工具和框架结合，形成完整的解决方案。

​		本项目中，内容的全局搜索，使用Elasticsearch完成。



## 第3章、 系统需求分析

### 3.1、业务分析

​		目前业界的在线学习社区，大多只能提供单一的功能，不能满足大多数用户的需求，用户通常需要在多个平台之间切换；另外，鲜有平台对第三方开发者友好，自有接口不对外开放。本平台就是基于以上需求，为有学习交流的国内大学生提供一个学习社区，在社区里，同学们可以自由进行知识分享、发布问题寻求他人的解答、发布自定义视频课程、关注与私信他人以获取最新资讯。从产品战略考虑，这样的平台在拥有了庞大的用户量之后，可以进行更多方面的拓展和进行商业化探索。

​		本在线学习社区（以下简称系统），主要面向的用户是国内在校大学生以及具有拓展学习需求的已进入职场人员，主要为有学习、分享、交流的人提供一个一站式在线学习社区。系统用户可以在社区中自由发布自己的学习心得，可以上传视频自定义制作课程，可以在社区中提问和回答他人问题，也可以作为一个日常记录，发布短内容记录生活感悟。围绕这一系列核心功能需求，还需要拥有诸如内容管理、消息通知等外围功能需求。



### 3.2、系统功能性分析

​		基于微服务架构的在线学习社区系统的初衷是为了给有学习需求的人提供一个在线交流分享的平台。系统搭建部署完成后，用户可以在Web端浏览自己感兴趣的内容。

​		系统前端页面需要简洁且交互友好，在用户登录进入系统后，系统需要为用户展示课程广场、答疑广场、随笔广场和想法广场，用户在不同的广场内可以查看和发布特点内容。四大广场的功能具体描述如下：

​		（1）课程广场：课程广场用于发布视频课程集合，系统为用户展示课程分类，课程列表，课程封面。用户点击对应课程课查看课程详情，包括课程的播放地址、课程的评论以及作者对课程的介绍。

​		（2）答疑广场：答疑广场用于提供用户一个提问的空间，用户可以在这里发布问题并邀请他人回答，其他用户可以进入问题，查看评论和回答，并且参与回答。

​		（3）随笔广场：随笔广场是一个发布大型内容的空间，提供强大的富文本编辑功能，用户可以在这里发布自己的学习心得体会、分享技术教程，也可以当做一个个人博客进行管理。

​		（4）想法广场：想法广场是一个发布轻型内容的区域，用户可以在此发布一些短内容，支持文字和图片。

​		除了广场被动地给用户推送内容以外，用户还可以进行全局内容搜索，主动查找感兴趣的内容。

​		用户在平台发布内容后，需要有管理内容的能力。系统为用户提供所有发布内容的后台管理功能，在管理页面可以对自己发布的所有课程、问题、回答、随笔、想法进行管理，包括隐藏、删除、编辑等操作，同时可以在个人中心进行个人信息的维护。

​		当用户在系统中发现感兴趣的内容或者其它用户时，需要关注和收藏功能以记录内容。因此系统为用户提供内容的收藏功能和用户的关注功能。用户可以收藏自己喜欢的内容，并在管理页面中快速找到这些内容，同时可以关注特定用户，当用户发布内容时获得第一时间的提醒，提醒分为站内和站外提醒，站内提醒方式为系统私信，站外提醒方式为邮件。

​		用户关注了其它用户后，会产生社交的需求，因此在个人中心用户可以维护自己的关注列表和粉丝列表，同时可以在任何地方点击他人用户头像进行关注和私信，系统具有强大的在线对话能力。

​		除开提供给用户的功能外，系统对认证后的第三方开发者提供完备且详细的Restful接口文档，认证后的第三方开发者通过AppKey和AppSecret可以调用系统接口进行定制化开发，制作自己想要的前台效果，实现系统资源的充分利用。

​		在完成上述业务基本功能需求以外，还需要考虑系统在技术层面的需求。首先作为一个分布式系统，需要有统一的注册中心负责服务的发现和请求路由，并且通过心跳机制监控各个服务的运行状态，保证系统的平稳运行。此外，需要搭建可靠、易于部署的服务器环境，实现项目的快速上下线和服务的自动扩缩容。系统需要用户登录才可以进行后续操作，因此需要统一的鉴权登录中心，统一地对用户进行认证和授权，一次授权，多点使用，其他服务也依赖认证与授权服务实现权限控制。



### 3.3、非功能性需求分析

​		在完成以上的基本需求功能后，还需要考虑系统的非功能性需求。非功能性需求在于系统能长久稳定地提供服务以及带给用户良好的使用体验。因此，本系统主要在以下非功能性需求入手：

​		（1）稳定性和可靠性：

​		考虑到分布式系统网络通信的不可靠性，需要充分利用诸如MySQL主从复制、Redis磁盘持久化等操作，防止服务由于网络不稳定或者部分微服务意外下线导致数据丢失，同时做好分布式数据的一致性工作。系统出现异常时，应当记录相关的日志信息，方便后续复现和修正。同时结合注册中心的心跳检测机制，做好服务的集群部署，确保应用的高可用，即使部分下线也不会影响整体系统的运行。

​		（2）易用性：

​		在线社区系统的前端页面应该轻松、明快、简约，符合当下一般用户的操作和审美休干，当用户误操作或者错误操作时，系统应该给出合适的提示信息。提高系统的交互友好度，在一些必要界面需要基于用户操作指引，让用户能够快速上手。

​		（3）安全性：

​		在设计系统架构时需要考虑系统的安全性。安全性主要考虑两方面，一方面是对服务数据的保密和脱敏，一方面是对服务恶意攻击的防御。前者需要在设计接口时做好接口的验证和验权操作，涉及到用户隐私例如手机号、邮箱、密码等信息时需要做好加密处理；对于恶意攻击，需要做好流量控制，检测到大量恶意请求时利用黑白名单制度屏蔽掉恶意IP。

​		（4）可扩展性：

​		可扩展性作为分布式系统的一大特点，需要特别注意。由于系统开发完成后还需要不断更新迭代，要做好接口的适配与更新，同时尽可能利用优秀的设计模式和编程规范，降低代码冗余，实现系统间的高内聚低耦合。项目由多个微服务模块构成，每个模块独立开发，独立部署，因此在需求层面要明确各个模块的边界，满足开闭原则，单一职责原则。



## 第4章、 系统设计和实现

### 4.1、系统架构设计

​		本系统使用微服务方式设计与拆分，在架构上，重点表现为微服务框架在业务交互过程中所表现出来的便捷性和易用性。整个系统框架以业务逻辑的实现为工作核心，系统入口为前端Web页面，后端入口为SpringCloudGateWay网关服务，承接外部流量，将请求转发到内部子服务。业务被划分为八个微服务：系统核心服务、认证中心服务、定时任务服务、内容服务、通知服务、外部API接入服务、文件服务、消息队列消费者服务。如图4.1所示。系统软件层次结构图如4-2所示。从功能层面，系统可以分为内容发布与推荐、内容与个人信息管理、系统通知与私信、三方API开放等，每个功能下又分为更小的业务颗粒，社区系统的功能模块如图4-3所示。

![图 4-1 系统架构设计图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\5.jpg)



![系统软件层次结构图 4-2](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\7.jpg)



![图4-3 社区系统功能模块图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\6.jpg)





​		从系统层次角度分析：

​		数据访问层：系统中的每个微服务模块基本数据会存放在MySQL关系型数据库中，对于一些需要搜索的数据，会另外存储一份进入ElasticSearch数据搜索引擎，对于一些经常需要访问的的数据，记录用户登录信息、字典信息、用户权限信息、内容访问记录等会放在Redis中进行存储。

​		中间件层：系统中每个服务不是完全独立的，一个模块的一个业务可能依赖于另外模块的功能，因此不同模块之间需要通信。以发布内容为例，除了基本的文字内容发布以外，发布物中还可能会包含图片、视频等文件型内容，需要调用统一的文件上传服务支持，另外，发布完成后，对于关注了的用户需要进行通知，此时需要调用通知模块向对应用户发送通知，如果全部采用同步调用方式，会导致服务调用链路过长，用户响应时间过长，体验糟糕。此时通过消息中间件来达到异步通信和解耦的作用，上游服务只需要向消息队列发送一条消息，不必等待结果的返回，下游服务接收到消息后进行处理即可，大大增加了效率和提高了用户体验。

​		服务层：本系统划分出了八个微服务模块，每个微服务通过Docker容器化进行资源环境的相互隔离，通过SpringBoot框架快速进行模块的搭建和分层及开发。

​		网关层：网关层包括注册中心、网关代理等。通过注册中心，可以检测到各个服务实例的健康状况，使用负载均衡算法来选择负载均衡算法来选择负载比较低的实例提供服务。同时系统的服务间调用也是基于注册中心的，每个微服务将自己注册到注册中心，调用其它服务时，向注册中心询问其他服务的低画质，SpringCloudGateWay网关代理从注册中心获得系统所有微服务的信息，对请求按照一定的规则进行路由映射转发到相应的微服务，同时网关还有解决全局跨域，进行全局拦截、过滤功能，比如登录凭证验证和XSS防御等。

​		系统入口：该层即为用户提供访问页面，前端通过Vue和ElementUI组件库进行搭建，当然还可以通过第三方租户接入直接调用接口进行访问。



### 4.2、系统环境搭建

​		表 4-1 为系统环境配置

| 配置名称             | 版本                     |
| -------------------- | ------------------------ |
| 操作系统             | Windows 10               |
| 开发语言             | JDK 1.8                  |
| 数据访问层           | MyBatis 3.4.2            |
| IDE                  | IntelliJ IDEA 2019       |
| 关系型数据库         | MySQL 8.0                |
| 缓存数据库           | Redis 5.0.8              |
| 项目管理工具         | Maven 3.3.9              |
| 前端运行环境         | Vue 2.0                  |
| 日志                 | Log4j 1.2.17             |
| Spring Boot          | 2.7.18                   |
| Spring Cloud         | 2021.0.8                 |
| Spring Cloud Alibaba | 2021.0.5.0               |
| 消息中间件           | RocketMQ 2.0.2           |
| 搜索引擎             | Elasticsearch 7.7.0      |
| 文件上传服务         | Minio RELEASE.2021-06-17 |



​		Linux环境搭建如图 4-4 所示，采用Docker部署。

![图 4-4 Linux环境搭建图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\8.jpg)



### 4.3、系统数据库详细设计

​		再开始详细介绍业务功能实现前，先介绍系统数据库详细设计，以便后续基于数据库的功能逻辑介绍。



#### 4.3.1、系统ER图设计

​		根据系统数据库设计，抽象出用户、课程、视频、问题、回答、随笔、想法、评论等实体，系统主要的数据表包括用户表、关注表、点赞表、内容表、评论表、课程表、视频表等，抽象出的 E-R图 如 图 4-5 所示。

![图 4-5 系统E-R图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\9.jpg)





#### 4.3.2、数据库表结构设计

​		用户表是反映用户信息的数据表。主要字段包括用户Id、部门Id、用户账号、用户昵称、用户邮箱、手机号码、用户性别、头像地址、密码、账号状态、创建时间、备注等字段，如表 4-1 所示

表 4-1 sys_user 用户表

| 字段名      | 数据类型 | 长度 | 备注     |
| ----------- | -------- | ---- | -------- |
| user_id     | bigint   |      | 用户Id   |
| dept_id     | bigint   |      | 部门Id   |
| user_name   | varchar  | 30   | 用户账号 |
| nick_name   | varchar  | 30   | 用户昵称 |
| user_type   | varchar  | 2    | 用户类型 |
| email       | varchar  | 50   | 用户邮箱 |
| phonenumber | varchar  | 11   | 手机号码 |
| sex         | char     | 1    | 用户性别 |
| avatar      | varchar  | 100  | 头像地址 |
| password    | varchar  | 100  | 密码     |
| status      | char     | 1    | 账号状态 |
| create_time | datetime |      | 创建时间 |
| remark      | varchar  | 500  | 备注     |



​		用户业务信息表是用户表的扩展，主要存储一些用户的业务信息，例如粉丝数、关注数、点赞数等，如表4-2所示。

表 4-2 biz_user 用户业务信息表

| 字段名       | 数据类型 | 长度 | 备注     |
| ------------ | -------- | ---- | -------- |
| user_id      | int      |      | 用户Id   |
| follower_cnt | int      |      | 粉丝数   |
| sub_cnt      | int      |      | 关注数   |
| like_cnt     | int      |      | 获赞总数 |



​		用户关注表记录了用户的关注信息，如表 4-3 所示。

表 4-3 biz_follow_list 用户关注表

| 字段名      | 数据类型 | 长度 | 备注     |
| ----------- | -------- | ---- | -------- |
| user_id     | int      |      | 用户id   |
| follower_id | int      |      | 粉丝id   |
| create_time | datetime |      | 关注时间 |



​		内容表是系统的一张核心表，系统的发布内容都会抽象成一条记录进入该表，主要字段包括内容id、作者id、标题、状态、分类、点赞数、评论数、浏览数、收藏数等等一系列字段，如表 4-3 所示。

表 4-3 blog 内容表

| 字段名           | 数据类型 | 长度 | 备注                                                  |
| ---------------- | -------- | ---- | ----------------------------------------------------- |
| id               | int      |      | 内容id                                                |
| author_id        | int      |      | 作者id                                                |
| title            | blob     |      | 内容标题                                              |
| preview          | blog     |      | 预览                                                  |
| status           | int      |      | 状态，1：已发布，2：尽自己可见，3：回答被采纳         |
| deleted          | int      |      | 是否删除，0：否，1：是                                |
| release_time     | varchar  | 100  | 发布时间                                              |
| create_time      | datetime |      | 创建时间                                              |
| like_cnt         | int      |      | 点赞数                                                |
| comment_cnt      | int      |      | 评论数                                                |
| view_cnt         | int      |      | 浏览量数                                              |
| collect_cnt      | int      |      | 收藏数                                                |
| article_classify | int      |      | 文章分类                                              |
| person_classify  | int      |      | 个人分类                                              |
| type             | int      |      | 内容类型，1：想法、2：随笔，3：提问，4：回答，5：课程 |
| pic_urls         | blob     |      | 想法图片的URL串，英文逗号分隔                         |
| qtn_p_id         | int      |      | 类型为回答时，对应的问题id                            |
| course_id        | int      |      | 所属课程Id                                            |
| video_id         | varchar  | 200  | 课程对应视频id                                        |
| chapter_id       | int      |      | 对应章节id                                            |
| chapter_order    | int      | 10   | 章节内顺序                                            |



​		课程表是课程广场的核心表，记录了课程的基本信息，如表 4-4 所示。

表 4-4 course 课程表

| 字段名      | 数据类型 | 长度 | 备注             |
| ----------- | -------- | ---- | ---------------- |
| course_id   | int      |      | 课程id           |
| author_id   | int      |      | 作者id           |
| title       | varchar  | 255  | 课程名称         |
| cover_pic   | varchar  | 255  | 课程封面图片地址 |
| create_time | datetime |      | 创建时间         |
| desc        | varchar  | 255  | 课程简介         |

​	

​		收藏表记录了用户对内容的收藏信息，如表 4-5 所示。

表 4-5 blog_collected 收藏表

| 字段名      | 数据类型 | 长度 | 备注     |
| ----------- | -------- | ---- | -------- |
| id          | int      |      | 记录id   |
| user_id     | int      |      | 用户id   |
| blog_id     | int      |      | 内容id   |
| create_time | datetime |      | 操作时间 |



​		评论表是评论功能的核心表，抽象出了对各种内容的评论，主要字段包括内容id、评论内容、评论人id、父评论id等，如表 4-6 所示。

表 4-6 blog_comment 评论表

| 字段名      | 数据类型 | 长度 | 备注                         |
| ----------- | -------- | ---- | ---------------------------- |
| id          | int      |      | 评论id                       |
| blog_id     | int      |      | 对应的内容id                 |
| sender_id   | int      |      | 发送者id                     |
| receiver_id | int      |      | 被回复者id，若一级评论则为-1 |
| parent_id   | int      |      | 父评论id                     |
| create_time | datetime |      | 创建时间                     |
| deleted     | int      |      | 是否删除，0：否，1：是       |
| content     | varchar  | 5000 | 评论内容                     |
| like_cnt    | int      |      | 点赞数                       |

​	

​		发布物内容表是针对长文发布物的具体内容表，支持记录前端富文本编辑器记录的格式化内容，如表 4-7 所示。

表 4-7 blog_content 发布物内容表

| 字段名             | 数据类型   | 长度 | 备注                      |
| ------------------ | ---------- | ---- | ------------------------- |
| blog_id            | int        |      | 对应的内容id              |
| content            | blob       |      | 文本型内容                |
| content_formatting | mediumblob |      | Quill编辑器格式化后的内容 |
| content_html       | mediumblob |      | HTML文本内容              |
| deleted            | int        |      | 是否删除，0：否，1：是    |



​		点赞表记录用户对内容的点赞信息，如表 4-8 所示。

表 4-8 blog_liked 点赞表

| 字段名      | 数据类型 | 长度 | 备注     |
| ----------- | -------- | ---- | -------- |
| id          | int      |      | 记录id   |
| user_id     | int      |      | 用户id   |
| blog_id     | int      |      | 内容id   |
| create_time | datetime |      | 操作时间 |



​		与内容点赞表类型的，还要评论点赞表，记录用户对评论的点赞信息，如表 4-9 所示。

表 4-9 comment_liked 评论点赞表

| 字段名      | 数据类型 | 长度 | 备注     |
| ----------- | -------- | ---- | -------- |
| id          | int      |      | 记录id   |
| user_id     | int      |      | 用户id   |
| comment_id  | int      |      | 评论id   |
| create_time | datetime |      | 操作时间 |



​		课程章节表记录课程的章节信息，一个课程会包含多个章节，如表 4- 10 所示。

表 4-10 course_chapter 课程章节表

| 字段名       | 数据类型 | 长度 | 备注     |
| ------------ | -------- | ---- | -------- |
| chapter_Id   | int      |      | 章节id   |
| course_id    | int      |      | 课程id   |
| chaper_order | int      |      | 章节顺序 |
| title        | varchar  | 255  | 章节标题 |
| desc         | varchar  | 255  | 章节描述 |



​		个人分类表用于随笔广场，用户可以创建个人分类，并将自己发布的随笔进行分类，如表 4-11 所示。

表 4-11 personal_classification 个人分类表

| 字段名      | 数据类型 | 长度 | 备注     |
| ----------- | -------- | ---- | -------- |
| id          | int      |      | 记录id   |
| user_id     | int      |      | 用户id   |
| class_name  | varchar  | 100  | 分类名称 |
| create_time | datetime |      | 创建时间 |





### 4.4、系统核心功能实现

​		根据图4-3的系统核心功能，下面将对各个功能的实现进行描述，并给出系统运行时的实例截图。

​		由于大部分业务功能的实现涉及到多个微服务之间进行协作，所以先对各个微服务的职责进行简要阐述。

​		系统核心服务 system-service：负责系统的核心非业务功能，例如用户的登录注册、用户信息维护、用户权限管理、菜单管理、枚举值管理、权限管理等。

​		认证中心服务 auth-service：负责系统的认证服务，单点登录鉴权等。

​		定时任务服务 job-service：统一负责系统的各个定时任务，所有的定时任务需要发布到这个服务上，并由这个服务进行执行。

​		内容服务 blog-service：系统核心业务服务，负责内容的发布、管理和推荐，

​		通知服务 notify-service：负责用户的站内私信、站内通知、站外通知等功能。

​		文件服务 file-service：负责图片和视频等多媒体文件的上传和管理功能，为其他业务服务提供文件管理能力。

​		消息队列消费者服务 mq-consumer-service：mq的消费者集群，负责在系统下游消费消息。

​		



#### 4.4.1、内容发布与推荐

##### 4.4.1.1、课程发布

​		课程发布的核心功能是视频的上传、播放和删除。本系统中，使用阿里云视频点播服务进行实现。系统前端视频播放使用开源视频播放器DPlayer实现。具体流程为：1.开通阿里云视频点播服务，获取AppSecretId和APPSecretKey。2.前端视频上传到后端服务，后端调用阿里云视频上传API，将用户上传的视频转储到阿里云服务器上。3.上传视频后会返回上传视频的视频Id，系统后端记录这个视频Id。4.播放视频时，通过后端记录的视频Id，调用阿里云视频点播获取视频播放地址。5.前端获取视频播放地址，通过DPlayer播放器实现播放。6.用户删除视频时，根据视频在后端保存的视频Id，调用阿里云API删除视频。流程图和效果图如下图所示。

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\28.jpg)

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\29.jpg)



​		视频上传所需的阿里云视频点播SDK依赖如下：

```xml
            <!-- 阿里云视频点播一系列依赖 -->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>4.5.1</version>
                <scope>system</scope>
                <systemPath>E:/WorkProject/RuoYi-Cloud/lib/aliyun-java-sdk-core-4.5.1.jar</systemPath>
            </dependency>
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>3.10.2</version>
                <scope>system</scope>
                <systemPath>E:/WorkProject/RuoYi-Cloud/lib/aliyun-sdk-oss-3.10.2.jar</systemPath>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-vod</artifactId>
                <version>2.16.11</version>
                <scope>system</scope>
                <systemPath>E:/WorkProject/RuoYi-Cloud/lib/aliyun-java-sdk-vod-2.16.11.jar</systemPath>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.68.noneautotype</version>
                <scope>system</scope>
                <systemPath>E:/WorkProject/RuoYi-Cloud/lib/fastjson-1.2.68.noneautotype.jar</systemPath>
            </dependency>
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>20170516</version>
            </dependency>
            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>2.8.2</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun.vod</groupId>
                <artifactId>upload</artifactId>
                <version>1.4.15</version>
                <scope>system</scope>
                <systemPath>E:/WorkProject/RuoYi-Cloud/lib/aliyun-java-vod-upload-1.4.15.jar</systemPath>
            </dependency>
            <!-- https://mvnrepository.com/artifact/io.opentracing/opentracing-api -->
            <dependency>
                <groupId>io.opentracing</groupId>
                <artifactId>opentracing-api</artifactId>
                <version>0.31.0</version>
            </dependency>
            <!-- https://mvnrepository.com/artifact/io.opentracing/opentracing-util -->
            <dependency>
                <groupId>io.opentracing</groupId>
                <artifactId>opentracing-util</artifactId>
                <version>0.33.0</version>
            </dependency>

            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>tea-console</artifactId>
                <version>0.0.1</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>tea-util</artifactId>
                <version>0.2.10</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>darabonba-env</artifactId>
                <version>0.1.1</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>vod20170321</artifactId>
                <version>2.0.0</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>tea-openapi</artifactId>
                <version>0.0.8</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>tea</artifactId>
                <version>[1.0.3, 2.0.0)</version>
            </dependency>
```

​		除了视频上传这一核心动作，课程发布还涉及其它内容。

​		课程广场是一个课程展示和管理的页面。用户可以在这里查看最新、最热的课程，也可以发布和管理自己已发布的课程，是课程功能主要的对外窗口。页面样式如下图。

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\31.jpg)

​		有关课程热门榜的实现，在后文的热门内容推荐章节进行统一介绍。此外页面上主要包含三个功能：猜你喜欢、最新发布、热门课程和我的课程的列表查询、右侧上方标题搜索框的查询、右侧下方发布课程功能。

​		课程的列表查询抽象了几种不同查询方式的区别和相同点，不同查询方式的主要区别在于查询条件和排序方式，抽象出这些点后统一进行代码设计，旨在提高代码的复用率。主要流程是，根据查询方式组装查询条件和排序方式；从数据库中查询原始数据；组装数据为前端需要的格式返回。核心代码如下所示：

```java
    @Override
    public List<CourseListVo> list(CourseListDto dto) {

        Course course = getListCourseDto(dto);
        Integer order = getListOrder(dto);
        List<Course> courseList = courseMapper.list(
                course,
                dto.getPageSize(),
                SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize()),
                order);

        if (CollectionUtils.isEmpty(courseList)) {
            return new ArrayList<>();
        }

        return convertCourse2Vo(courseList);
    }

    private Integer getListOrder(CourseListDto dto) {
        CourseListTypeEnum listType = CourseListTypeEnum.getEnum(dto.getListType());

        switch (listType) {
            case RANDOM:
                return BlogOrderEnum.RAND.getOrder();
            case HOTTEST:
                return BlogOrderEnum.HOT_RANK.getOrder();
            case LATEST:
            case MINE:
                return BlogOrderEnum.TIME_DESC.getOrder();
            default:
                break;
        }
        return null;
    }

    private Course getListCourseDto(CourseListDto dto) {
        CourseListTypeEnum listType = CourseListTypeEnum.getEnum(dto.getListType());
        Course course = new Course();
        switch (listType) {
            case AUTHOR:
                course.setAuthorId(dto.getUserId());
                break;
            case MINE:
                course.setAuthorId(SecurityUtils.getUserId());
                break;
            case RANDOM:
            case HOTTEST:
            case LATEST:
                break;
            default:
                // unreachable
                throw new RuntimeException("枚举值不存在");
        }

        if (StringUtils.isNotEmpty(dto.getTitle())) {
            course.setTitle(dto.getTitle());
        }

        return course;
    }
```

​		

​		点击课程进入课程详情页，详情页主要由两部分组成，左侧的章节列表和右侧的视频播放器和视频信息。样式如上图所示。章节列表为根据课程章节设置的多级菜单。右侧引入DPlayer进行进行视频播放。视频播放器的前端代码简单示例如下：

```html
<template>

  <div class="app-container">
    <h1>测试视频上传和播放</h1>

    <div>
      上传视频的按钮
      <file-upload upload-type="vod" :file-size="500" :limit="1" @vodUploadSuccess="handleSuccess"/>
    </div>

    <div>
      {{'上传后获取的视频Id为：' + vodId}}
    </div>

    <div>
      <el-button type="success" round @click="getVodUrl">点击获取替换视频播放地址</el-button>
    </div>

    <div>
      {{'当前的视频播放地址为：' + this.vodUrl}}
    </div>

    <div>
      <el-button type="danger" round @click="delVod">点击删除刚才上传的视频</el-button>
    </div>

    <div id="dplayer" style="height: 1000px; width: 1800px"/>
  </div>

</template>

<script>

import DPlayer from 'dplayer';
import {delVodUrl, getVodUrl} from "@/api/biz/vod";

export default {
  name: 'TestVideo',
  data() {
    return {
      dp: {},
      vodId: '',
      vodUrl: 'https://outin-876cab0e0e7d11edbae200163e1a65b6.oss-cn-shanghai.aliyuncs.com/sv/21dff8a6-182493b39d3/21dff8a6-182493b39d3.mp4?Expires=1712497377&OSSAccessKeyId=LTAI3DkxtsbUyNYV&Signature=%2B1tkP6Emc5ZqFxSFCZVE5XLm6js%3D',
    }
  },
  created() {
  },
  mounted() {
    this.dp = new DPlayer({
      container: document.getElementById('dplayer'),
      video: {
        url: this.vodUrl,
      },
    });
  },
  methods: {
    handleSuccess(vodId) {
      this.$message({
        message: '视频上传成功！视频Id为：' + vodId,
        type: 'success'
      })
      this.vodId = vodId
    },
    delVod() {
      if (!this.vodId || this.vodId.trim().length === 0) {
        this.$message({
          message: '请先上传视频！',
          type: 'error'
        })
        return
      }

      delVodUrl(this.vodId).then(resp => {
        if (resp.code === 200) {
          this.vodUrl = ''
          this.dp.destroy()

          this.$message({
            message: '删除视频成功！',
            type: 'success'
          })
        } else {
          this.$message({
            message: resp.msg,
            type: 'error'
          })
        }
      })

    },
    getVodUrl() {
      if (!this.vodId || this.vodId.trim().length === 0) {
        this.$message({
          message: '请先上传视频！',
          type: 'error'
        })
        return
      }
      getVodUrl(this.vodId).then(resp => {
        if (resp.code === 200) {
          this.$message({
            message: '获取视频播放地址成功',
            type: 'success'
          })
          this.vodUrl = resp.msg
          this.dp.destroy()
          this.dp = new DPlayer({
            container: document.getElementById('dplayer'),
            video: {
              url: this.vodUrl,
            },
          });
        } else {
          this.$message({
            message: resp.msg,
            type: 'error'
          })
        }
      })
    }
  }
}

</script>
```

​		

​		由主页进入课程编辑页面。课程编辑分为两步，第一步设置课程标题、课程简介和课程封面图片；第二步设置具体的章节信息和每一小节对应的视频。课程编辑页面样式由下图展示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\32.jpg)

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\33.jpg)

​		后端代码的主要流程即为接收前端参数保存即可，核心代码如下：

```java
    @Override
    public long postCourse(PostCourseDto dto) {
        Long userId = SecurityUtils.getUserId();
        Course course = new Course();
        course.setAuthorId(userId);
        course.setTitle(dto.getCourse().getTitle());
        course.setCoverPic(dto.getCourse().getCoverPic());
        course.setDesc(dto.getCourse().getDesc());
        if (dto.getCourseId() != null && dto.getCourseId() > 0) {
            course.setCourseId(dto.getCourseId());
            courseMapper.updateCourse(course);
        } else {
            courseMapper.insertCourse(course);
        }

        // 删除所有的chapter和vod
        courseMapper.delChapterByCourseId(course.getCourseId());
        courseMapper.delVodByCourseId(course.getCourseId());


        dto.getChapterList().forEach(c -> {
            CourseChapter chapter = new CourseChapter();
            chapter.setCourseId(course.getCourseId());
            chapter.setTitle(c.getTitle());
            chapter.setDesc(c.getTitle());

            courseMapper.insertChapter(chapter);

            List<Blog> vodList = c.getVodList().stream().map(v -> {
                Blog vod = new Blog();
                vod.setAuthorId(userId);
                vod.setTitle(v.getTitle());
                vod.setPreview(v.getPreview());
                vod.setStatus(BlogStatusEnum.PUBLISHED.getStatus());
                vod.setReleaseTime(DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS, new Date()));
                vod.setType(BlogTypeEnum.VIDEO.getType());
                vod.setCourseId(course.getCourseId());
                vod.setChapterId(chapter.getChapterId());
                vod.setVideoId(v.getVideoId());

                return vod;
            }).collect(Collectors.toList());

            courseMapper.insertVideoBatch(vodList);
        });

        return course.getCourseId();
    }

```



##### 4.4.1.2、问题发布

​		问题广场是系统的核心功能之一。用户在这里发布和回答问题，承载了重要的教育功能。

​		问题广场的首页展示了不同类别的问题和热门问题，样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\34.jpg)

​		前端问题列表查询的后端核心代码如下：

```java

    @Override
    public List<QtnSquareVo> list(QtnSquareDto dto) {
        Blog blog = new Blog();
        blog.setType(BlogTypeEnum.QUESTION.getType());
        blog.setStatus(BlogStatusEnum.PUBLISHED.getStatus());

        BlogOrderEnum orderEnum = BlogOrderEnum.getEnum(dto.getBlogOrder());

        List<Blog> qtnList = blogMapper.getArticleList(
                blog,
                dto.getPageSize(),
                SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize()),
                orderEnum.getOrder()
        );

        if (CollectionUtils.isEmpty(qtnList)) {
            return new ArrayList<>();
        }

        // 查询作者个人信息
        List<Long> authorIdList = qtnList.stream().map(Blog::getAuthorId).collect(Collectors.toList());
        List<UserBasicInfoVo> basicInfoList = remoteUserService
                .getUserBasicInfoByIds(authorIdList, SecurityConstants.INNER).getData();
        Map<Long, List<UserBasicInfoVo>> basicInfoMap = basicInfoList
                .stream().collect(Collectors.groupingBy(UserBasicInfoVo::getId));

        // 查询是否点赞、收藏信息、回答数
        String userId = SecurityUtils.getUsername();
        List<Long> qtnIdList = qtnList.stream().map(Blog::getId).collect(Collectors.toList());

        // 这里的 map 是key为列名，value为列值，需要转换为key为qId，value为ansCnt的格式
        List<Map<String, String>> ansCnt = blogMapper.getAnsCntByIds(qtnIdList);

        Map<Long, Long> ansCntMap = new HashMap<>();

        ansCnt.forEach(e -> ansCntMap.put(SqlUtil.cast2Long(e.get("q_id")), SqlUtil.cast2Long(e.get("ans_cnt"))));

        List<Long> likedIds = blogLikedMapper.selectLikedIds(qtnIdList, userId);
        Set<Long> likedSet = new HashSet<>(likedIds);

        List<Long> collectedIds = blogCollectedMapper.selectCollectedIds(qtnIdList, userId);
        Set<Long> collectSet = new HashSet<>(collectedIds);

        return qtnList.stream().map(q -> {
            UserBasicInfoVo basicInfoVo = basicInfoMap.get(q.getAuthorId()).get(0);
            QtnSquareVo vo = new QtnSquareVo();
            vo.setQtnId(q.getId());
            vo.setAuthor(basicInfoVo);
            vo.setTitle(q.getTitle());
            vo.setPreview(q.getPreview());
            Long ac = ansCntMap.get(q.getId());
            vo.setAnsCnt(ac == null ? 0 : ac);
            vo.setLikeCnt(q.getLikeCnt());
            vo.setViewCnt(q.getViewCnt());
            vo.setCollectCnt(q.getCollectCnt());
            vo.setPublishTime(q.getReleaseTime());
            vo.setLiked(likedSet.contains(q.getId()));
            vo.setCollected(collectSet.contains(q.getId()));
            return vo;
        }).collect(Collectors.toList());
    }
```



​		在问题广场点击问题，进入对应的问题查看页面，左侧详细展示了问题标题和内容，右侧是回答区，用户可以在这里编辑对问题的回答，左侧下方展示该问题的回答列表，问题作者可以选择一个回答进行采纳，样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\35.jpg)



​		问题和回答的展示和编辑支持富文本，本系统的前端富文本编辑使用开源组件Quill实现，具体的实现参考下下随笔发布部分。





##### 4.4.1.3、随笔发布

​		随笔广场是一个发布重文本内容的一块区域，相比于课程广场和问题广场，它的目的性较弱，相比于想法广场，它支持的内容更丰富。用户可以在这里查看到他人发布的长文本内容，也可以自己编辑大型图文内容，是一片类博客区域。随笔广场的左侧为随笔列表，会向用户推送各种随笔，右侧上方选择分类下拉框，可以定向选择不同分类下的随笔，右侧换一批按钮可以推送下一批，下方的三个排行榜分别为七天阅读排行榜、七天收藏排行榜和七天点赞排行榜，可以让用户查看到当前的最新趋势。随笔广场的样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\36.jpg)



​		点击随笔，会跳转到指定的浏览随笔的详情页，页面上方以富文本形式展示了随笔的完整内容，下方则是评论区。关于评论区的具体实现，参考后文内容评论章节。浏览随笔的前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\37.jpg)

​	

​		点击左侧目录内容管理下的子菜单新建随笔，可以进入新建随笔页面，在这里可以设置随笔标题、随笔内容，设置随笔的文章分类和个人分类。文章分类分为技术分享、新闻资讯、趣闻吐槽、心得总结和碎碎念，用户可以选择将文章直接发布或者设置为草稿，设置为草稿的随笔仅作者本人可查看。编辑随笔前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\38.jpg)



​		本系统的前端富文本编辑组件使用的为Quill，这是一个开源且功能强大的编辑组件。由其在系统的多处使用，故将其抽象出一个公共组件用于调用。前端核心代码如下：

```html
<template>
  <div>
    <!-- 这个upload是隐藏的，用于给输入框调用上传服务 -->
    <el-upload
      :action="uploadUrl"
      :before-upload="handleBeforeUpload"
      :on-success="handleUploadSuccess"
      :on-error="handleUploadError"
      name="file"
      :show-file-list="false"
      :headers="headers"
      style="display: none"
      ref="upload"
      v-if="this.type == 'url'"
    >
    </el-upload>
    <div class="editor" ref="editor" :style="styles"></div>
  </div>
</template>

<script>
import Quill from "quill";
import "quill/dist/quill.core.css";
import "quill/dist/quill.snow.css";
import "quill/dist/quill.bubble.css";
import { getToken } from "@/utils/auth";

export default {
  name: "Editor",
  props: {
    /* 编辑器的内容 */
    value: {
      type: String,
      default: "",
    },
    /* 高度 */
    height: {
      type: Number,
      default: null,
    },
    /* 最小高度 */
    minHeight: {
      type: Number,
      default: null,
    },
    /* 只读 */
    readOnly: {
      type: Boolean,
      default: false,
    },
    /* 上传文件大小限制(MB) */
    fileSize: {
      type: Number,
      default: 5,
    },
    /* 类型（base64格式、url格式） */
    type: {
      type: String,
      default: "url",
    },
    /* 该编辑器是否只用于展示 */
    forPresent: {
      type: Boolean,
      default: false
    },
    /* placeholder */
    placeHolder: {
      type: String,
      default: '请输入内容'
    },
    /* 开启字数限制 */
    enableLimit: {
      type: Boolean,
      default: false
    },
    /* 字数限制 */
    limitCount: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      uploadUrl: process.env.VUE_APP_BASE_API + "/file/upload", // 上传的图片服务器地址
      headers: {
        Authorization: "Bearer " + getToken()
      },
      Quill: null,
      currentValue: "",
      options: {
        theme: "snow",
        bounds: document.body,
        debug: "warn",
        modules: {
          // 工具栏配置
          toolbar: [
            ["bold", "italic", "underline", "strike"],       // 加粗 斜体 下划线 删除线
            ["blockquote", "code-block"],                    // 引用  代码块
            [{ list: "ordered" }, { list: "bullet" }],       // 有序、无序列表
            [{ indent: "-1" }, { indent: "+1" }],            // 缩进
            [{ size: ["small", false, "large", "huge"] }],   // 字体大小
            [{ header: [1, 2, 3, 4, 5, 6, false] }],         // 标题
            [{ color: [] }, { background: [] }],             // 字体颜色、字体背景颜色
            [{ align: [] }],                                 // 对齐方式
            ["clean"],                                       // 清除文本格式
            ["link", "image", "video"]                       // 链接、图片、视频
          ],
        },
        placeholder: this.placeHolder,
        readOnly: this.readOnly,
      },
    };
  },
  computed: {
    styles() {
      let style = {};
      if (this.minHeight) {
        style.minHeight = `${this.minHeight}px`;
      }
      if (this.height) {
        style.height = `${this.height}px`;
      }
      return style;
    },
  },
  watch: {
    value: {
      handler(val) {
        if (val !== this.currentValue) {
          this.currentValue = val === null ? "" : val;
          if (this.Quill) {
            this.Quill.pasteHTML(this.currentValue);
          }
        }
      },
      immediate: true,
    }
  },
  mounted() {
    this.init();
  },
  beforeDestroy() {
    this.Quill = null;
  },
  methods: {
    init() {
      const editor = this.$refs.editor;
      if (this.forPresent) {
        // 仅用于展示，去掉toolBar
        this.options.modules.toolbar = []
      }
      this.Quill = new Quill(editor, this.options);
      // 如果设置了上传地址则自定义图片上传事件
      if (this.type == 'url') {
        let toolbar = this.Quill.getModule("toolbar");
        toolbar.addHandler("image", (value) => {
          if (value) {
            this.$refs.upload.$children[0].$refs.input.click();
          } else {
            this.quill.format("image", false);
          }
        });
      }
      this.Quill.pasteHTML(this.currentValue);
      this.Quill.on("text-change", (delta, oldDelta, source) => {
        const html = this.$refs.editor.children[0].innerHTML;
        const text = this.Quill.getText();
        const quill = this.Quill;
        this.currentValue = html;
        this.$emit("input", html);
        this.$emit("on-change", { html, text, quill });
      });

      // 设置字数限制，每当内容改变时判断是否超过限制，如果超过则回滚本次内容改变
      if (this.enableLimit) {
        this.Quill.on("text-change", (delta, oldDelta, source) => {
          if (this.Quill.getLength() > this.limitCount + 1) {
            this.Quill.setContents(oldDelta)

            this.$message({
              message: '您的字数超过了 ' + this.limitCount + ' 字！\n 请缩短文本或者分次发布!',
              type: 'error'
            })

          }
        })
      }



      this.Quill.on("text-change", (delta, oldDelta, source) => {
        this.$emit("on-text-change", delta, oldDelta, source);
      });
      this.Quill.on("selection-change", (range, oldRange, source) => {
        this.$emit("on-selection-change", range, oldRange, source);
      });
      this.Quill.on("editor-change", (eventName, ...args) => {
        this.$emit("on-editor-change", eventName, ...args);
      });
    },
    // 上传前校检格式和大小
    handleBeforeUpload(file) {
      const type = ["image/jpeg", "image/jpg", "image/png", "image/svg"];
      const isJPG = type.includes(file.type);
      // 检验文件格式
      if (!isJPG) {
        this.$message.error(`图片格式错误!`);
        return false;
      }
      // 校检文件大小
      if (this.fileSize) {
        const isLt = file.size / 1024 / 1024 < this.fileSize;
        if (!isLt) {
          this.$message.error(`上传文件大小不能超过 ${this.fileSize} MB!`);
          return false;
        }
      }
      return true;
    },
    handleUploadSuccess(res, file) {
      // 如果上传成功
      if (res.code == 200) {
        // 获取富文本组件实例
        let quill = this.Quill;
        // 获取光标所在位置
        let length = quill.getSelection().index;
        // 插入图片  res.url为服务器返回的图片地址
        quill.insertEmbed(length, "image", res.data.url);
        // 调整光标到最后
        quill.setSelection(length + 1);
      } else {
        this.$message.error("图片插入失败");
      }
    },
    handleUploadError() {
      this.$message.error("图片插入失败");
    },
  },
};
</script>
```



​		前端编辑好内容后，会在后端保存三部分内容：纯文字内容、HTML格式内容、编辑器格式化JSON内容。纯文本内容记录用户输入信息，HTML格式用于前端展示，JSON内容用于编辑器编辑回显，这是因为富文本编辑器编辑的内容是以JSON格式在编辑器内存储的。保存随笔的后端核心代码如下：

```java
    @Override
    public Long postArticle(PostArticleDto dto) {
        Blog blog = new Blog();
        Long userId = SecurityUtils.getUserId();
        blog.setAuthorId(userId);
        blog.setTitle(dto.getTitle());
        blog.setStatus(dto.getStatus());
        blog.setArticleClassify(dto.getArticleClassify());
        blog.setPersonClassify(dto.getPersonClassify());
        blog.setType(BlogTypeEnum.ARTICLE.getType());

        if (blog.getStatus().equals(BlogStatusEnum.PUBLISHED.getStatus())) {
            blog.setReleaseTime(DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS, new Date()));
        }

        // 获取内容的前三百字为预览
        String content = dto.getContent();
        if (content.length() <= BlogConstants.PREVIEW_LENGTH) {
            blog.setPreview(content);
        } else {
            blog.setPreview(content.substring(0, 300));
        }

        // 如果dto存在id字段为更新，否则为删除
        boolean updateFlag = dto.getArticleId() != null && dto.getArticleId() != 0;
        if (updateFlag) {
            blog.setId(dto.getArticleId());
            blogMapper.updateBlogById(blog);
        } else {
            blogMapper.insertBlog(blog);
        }

        BlogContent blogContent = new BlogContent();
        blogContent.setBlogId(blog.getId());
        blogContent.setContent(dto.getContent());
        blogContent.setContentFormatting(dto.getContentFormatting());
        blogContent.setContentHtml(dto.getContentHtml());

        if (updateFlag){
            blogMapper.updateBlogContent(blogContent);
        } else {
            blogMapper.insertBlogContent(blogContent);
        }

        return blog.getId();
    }

```







##### 4.4.1.4、想法发布

​		想法的发布包含前端页面展示、详情查看、编辑并发布想法等。效果图如图4-8，图4-9，图4-10所示。

​		![图 4-8 想法广场前端样式](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\14.jpg)

![图 4-9 想法编辑前端样式](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\15.jpg)

![图 4-10 想法详情查看](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\16.jpg)

​		前端的页面样式包含以下几个要点：

​		1.广场首页可以查看已发布的想法帖子；

​		2.点击查看按钮，进入想法详情查看页面，可以查看全文和附带的图片，点击图片可放大查看；

​		3.点击右下角按钮换一批，可以推送另外一批想法；

​		4.点击右上角发布想法，下方出现抽屉，用户可以输入文字和上传视频，发布自己的想法。

​		5.点击右上角我的想法按钮，可以在页面展示内容为我的想法，用户可以选择删除自己已发布的想法。



​		根据业务功能需求，后端需要提供的主要接口为：

​		1.发布想法接口

​		2.查看想法详情接口

​		3.想法列表查询接口

​		4.想法删除接口



​		（1）发布想法接口：流程比较简单，核心思想就是从前端接收入参，落入内容表。核心代码如下：

```java
    @Override
    public long postBlog(PostBlogDto dto) {
        Long userId = SecurityUtils.getUserId();
        Blog blog = new Blog();
        blog.setAuthorId(userId);
        blog.setPreview(dto.getContent());
        blog.setStatus(BlogStatusEnum.PUBLISHED.getStatus());
        blog.setReleaseTime(DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS, new Date()));
        blog.setType(BlogTypeEnum.TWEET.getType());
        blog.setPicUrls(dto.getPicUrls());
        blogMapper.insertBlog(blog);
        return blog.getId();
    }
```

​		

​	（2）查看想法详情接口：根据随笔Id从数据表中查出想法详情数据，同时往消息队列投送一条消息，通知下游增加对应想法的浏览量计数。核心代码如下：

```java
    @Override
    public BlogDetailVo getBlogDetail(Long blogId) {
        BlogDetailVo vo = new BlogDetailVo();
        Blog blog = new Blog();
        blog.setId(blogId);
        List<Blog> list = blogMapper.getArticleList(blog, null, null, null);
        if (CollectionUtils.isEmpty(list)) {
            throw new ServiceException("想法不存在！");
        }
        blog = list.get(0);
        vo.setContent(blog.getPreview());
        vo.setCommentCnt(blog.getCommentCnt());
        vo.setViewCnt(blog.getViewCnt());
        vo.setLikeCnt(blog.getLikeCnt());
        if (StringUtils.isNotEmpty(blog.getPicUrls())) {
            vo.setPicUrlList(Arrays.asList(blog.getPicUrls().split("[,]")));
        }

        // 向下游发送通知,增加blog浏览量计数
        BlogMessage message = new BlogMessage();
        message.setMessageId(blogId);
        message.setBlogId(blogId);
        message.setBlogType(blog.getType());
        message.setOperateType(OperateType.ADD.getType());
        message.setType(BlogMessage.MessageType.VIEW.getType());
        rocketMQTemplate.asyncSendOrderly(
                MqTopicConstants.BLOG_TOPIC,
                message,
                String.valueOf(message.getMessageId()),
                new DefaultCallBack<>(this.getClass(), message)
        );

        return vo;
    }
```





​		（3）想法列表查询接口：前端有多种想法查询推荐模式，到后端根据不同的查询模式组装查询条件，最后根据前端所需的格式，组装返回值。核心代码如下：

```java
    @Override
    public List<IndexBlogVo> getBlogList(BlogListDto dto) {
        BlogQueryModeEnum queryMode = BlogQueryModeEnum.getEnum(dto.getQueryMode());
        List<Blog> blogList = new ArrayList<>();
        Blog blog = new Blog();

        switch (queryMode) {
            case BLOG_MANEGE:
                blog.setAuthorId(SecurityUtils.getUserId());
                blog.setType(BlogTypeEnum.TWEET.getType());
                blogList = blogMapper.getArticleList(
                        blog,
                        dto.getPageSize(),
                        SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize()),
                        queryMode.getOrderEnum().getOrder());

                break;
            case REGULAR:
                // TODO 需要重构
                blog.setType(BlogTypeEnum.TWEET.getType());
                blogList = blogMapper.getArticleList(
                        blog,
                        dto.getPageSize(),
                        0,
                        queryMode.getOrderEnum().getOrder());
                break;
            case LATEST:
                blog.setAuthorId(dto.getUserId());
                blog.setType(BlogTypeEnum.TWEET.getType());
                blogList = blogMapper.getArticleList(
                        blog,
                        1,
                        0,
                        queryMode.getOrderEnum().getOrder()
                );
                break;
            case PERSONAL_BLOG:
                blog.setAuthorId(dto.getUserId());
                blog.setType(BlogTypeEnum.TWEET.getType());
                blogList = blogMapper.getArticleList(
                        blog,
                        dto.getPageSize(),
                        SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize()),
                        queryMode.getOrderEnum().getOrder()
                );
                break;
            default:
                // unreachable
                break;
        }
        
        // 组装返回值
        return packBlogVoList(blogList);

    }

// 将数据表中查询出的 blogList 打包为前端需要的数据格式
    private List<IndexBlogVo> packBlogVoList(List<Blog> blogList) {
        List<IndexBlogVo> blogVoList = new ArrayList<>();
        if (CollectionUtils.isEmpty(blogList)) {
            return blogVoList;
        }

        List<Long> idList = blogList.stream().map(Blog::getAuthorId).collect(Collectors.toList());
        R<List<SysUser>> infoByIdsRes = remoteUserService.getInfoByIds(idList, SecurityConstants.INNER);
        List<SysUser> infoByIds = infoByIdsRes.getData();
        Map<Long, List<SysUser>> groupById = infoByIds.stream().collect(Collectors.groupingBy(SysUser::getUserId));

        Long userId = SecurityUtils.getUserId();

        blogVoList = blogList.stream().map(blog -> {
            IndexBlogVo blogVo = new IndexBlogVo();
            SysUser sysUser = groupById.get(blog.getAuthorId()).get(0);

            blogVo.setBlogId(blog.getId());
            blogVo.setAuthorId(sysUser.getUserId());
            blogVo.setAuthorFollowed(false); // 测试方法默认设置为未关注
            blogVo.setReleaseTime(blog.getReleaseTime());
            if (blog.getPreview().length() > BlogConstants.PREVIEW_LENGTH) {
                blogVo.setPreview(blog.getPreview().substring(0, BlogConstants.PREVIEW_LENGTH) + "······");
            } else {
                blogVo.setPreview(blog.getPreview());
            }
            blogVo.setLikeCnt(blog.getLikeCnt());
            blogVo.setViewCnt(blog.getViewCnt());
            blogVo.setCommentCnt(blog.getCommentCnt());
            blogVo.setSenderName(sysUser.getNickName());
            blogVo.setAvatar(sysUser.getAvatar());

            // 判断是否已点赞
            int liked = blogLikedMapper.isLiked(userId, blog.getId());
            blogVo.setLiked(liked > 0);

            // 获取picUrls
            String picUrls = blog.getPicUrls();
            if (picUrls != null && picUrls.length() > 0) {
                blogVo.setPicUrlList(Arrays.asList(picUrls.split("[,]")));
            }

            return blogVo;
        }).collect(Collectors.toList());
        return blogVoList;
    }
```



​		（4）想法删除接口：得益于我们将所有内容抽象到内容表，删除想法仅需删除表中的一条记录即可。核心代码如下：

```java
    @Override
    public int deleteArticle(IdDto id) {
        Long userId = SecurityUtils.getUserId();
        int blogDeleteCnt = blogMapper.deleteBlogById(id.getId(), userId);
        if (blogDeleteCnt == 0) {
            throw new ServiceException("删除失败！");
        }
        blogMapper.deleteContentById(id.getId());

        return blogDeleteCnt;
    }
```





##### 4.4.1.5、内容评论

​		回复功能针对系统中的所有发布内容，是一个通用功能。由于是通用功能，所以在多个页面会使用到评论功能，因此将评论区做成一个公共组件，实现代码的复用，需要使用的地方引用即可。评论区的样式图如图4-11 所示：

![图4-11 评论区前端样式](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\20.jpg)

​		前端样式包含以下几个要点：

​		（1）左上角显示评论总数；

​		（2）包含三种评论查询模式：最早、最新、最热；

​		（3）第二行为评论输入框，字数上限500字，回复的内容为发布物；

​		（4）评论为分层结构，可以对现有的评论进行评论，点击回复按钮，会在对应父评论下出现输入框；

​		（5）评论一次展示三条父评论，可点击下方加载更多按钮查看更多评论



​		根据前端业务需求，后端需要提供的接口为：

​		1.获取评论接口

​		2.发送评论接口



​		（1）获取评论接口：获取评论接口是一个比较复杂的接口，该接口需要获取的信息有：获取评论总数、获取每一个父评论、获取每一个父评论下的子评论、根据每一个评论的发送者和回复者id，获取对应发送者和回复者的个人信息、获取每一条评论相对于当前用户是否已点赞过信息。核心代码较长，伪代码如下：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\21.jpg)



​		（2）发送评论接口：根据评论内容、回复内容id、发送者id、接受者id，将评论写入数据库，同时向消息队列投送一条消息，通知下游服务计数，增加对应内容的评论数。核心代码如下：

```java
    @Override
    public boolean postComment(PostCommentDto dto) {
        BlogComment comment = new BlogComment();
        Long senderId = SecurityUtils.getUserId();
        comment.setBlogId(dto.getBlogId());
        comment.setContent(dto.getContent());
        comment.setSenderId(senderId);
        if (dto.getReceiverId() != null) {
            comment.setReceiverId(dto.getReceiverId());
        }
        if (dto.getParentId() != null) {
            comment.setParentId(dto.getParentId());
        }

        int flag = blogCommentMapper.putComment(comment);

        if (flag > 0) {
            Blog blog = new Blog();
            blog.setId(dto.getBlogId());
            blog = blogMapper.getArticleList(blog, null, null, null).get(0);
            // 下游通知blog评论数更新

            BlogMessage message = new BlogMessage();
            message.setMessageId(dto.getBlogId());
            message.setBlogId(dto.getBlogId());
            message.setBlogType(blog.getType());
            message.setOperateType(OperateType.ADD.getType());
            message.setType(BlogMessage.MessageType.COMMENT.getType());
            rocketmqTemplate.asyncSendOrderly(
                    MqTopicConstants.BLOG_TOPIC,
                    message,
                    String.valueOf(message.getBlogId()),
                    new DefaultCallBack<>(this.getClass(), message)
            );
        }

        return flag > 0;
    }
```



##### 4.4.1.6、计数功能

​		项目中很多地方需要使用到计数功能，例如内容的浏览量、点赞量、评论量、收藏量等，用户也会需要进行计数统计，例如获赞总数。因此，计数功能需要抽象出来做统一设计。

​		显然，计数功能存在并发问题，因为计数的过程是获取先获取旧值，再在旧值的基础上自增。对于分布式系统而言，可以使用分布式锁进行解决。不过我觉得简单地使用分布式锁并不优雅，可以使用mq进行实现，从流程上消除并发，并且保持良好的拓展性。下面先介绍基于mq实现计数功能的设计。

​		以随笔点赞为例，核心思想是，对于一篇随笔的所有请求，统一交到一个固定的comsumer处理，这个consumer不断负责数据表字段的更新，基于RocketMQ的分区消息模型，如图4-12 所示

![图4-12](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\22.jpg)

​		设置内容id为hashKey，该内容的所有计数消息会被投放到固定的一条队列，该队列会绑定一个固定的消费者，这样来自各个地方的计数消息会被汇总到一个单一的消费者，消除并发问题。同时，消费者可做集群化部署，将来如果流量激增，定向扩容即可，具有良好的拓展性。

​		具体实现：

​		（1）在RocketMQ中定义对应的Topic和ConsumerGroup

![定义Topic](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\23.jpg)

![定义ConsumerGroup](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\24.jpg)

​		（2）在消费者模块定义对应的消费者：

```java
@Component
@RocketMQMessageListener(
        topic = MqTopicConstants.BLOG_TOPIC,
        consumerGroup = MqConsumerGroupConstants.BLOG_GROUP,
        consumeMode = ConsumeMode.ORDERLY,
        messageModel = MessageModel.CLUSTERING)
public class BLogConsumer_1 implements RocketMQListener<BlogMessage>, RocketMQPushConsumerLifecycleListener {

    @Resource
    private BlogHandler handler;

    private static final Logger log = LoggerFactory.getLogger(BLogConsumer_1.class);

    @Override
    public void onMessage(BlogMessage message) {
        log.info("BLogConsumer_1 收到消息，message = {}", message);
        handler.handle(message);
    }

    @Override
    public void prepareStart(DefaultMQPushConsumer consumer) {
        consumer.setInstanceName("BLogConsumer_1");
    }
}
```

​		（3）上游触发对应业务功能时，向消息队列对应主题投送消息，同时指定内容id为hashKey：

```java
// 通知下游改变blog点赞计数
BlogMessage message = new BlogMessage();
message.setMessageId(blogId);
message.setBlogId(blogId);
message.setBlogType(blog.getType());
message.setOperateType(typeEnum.getType());
message.setType(BlogMessage.MessageType.LIKE.getType());
rocketMQTemplate.asyncSendOrderly(
        MqTopicConstants.BLOG_TOPIC,
        message,
        String.valueOf(message.getMessageId()),
        new DefaultCallBack<>(this.getClass(), message)
);

// 通知下游改变用户点赞计数
Long authorId = blog.getAuthorId();
UserMessage userMessage = new UserMessage();
userMessage.setUserId(authorId);
userMessage.setMessageId(authorId);
userMessage.setType(UserMessage.MessageType.LIKE.getType());
userMessage.setOperateType(typeEnum.getType());
rocketMQTemplate.asyncSendOrderly(
        MqTopicConstants.USER_TOPIC,
        userMessage,
        String.valueOf(message.getMessageId()),
        new DefaultCallBack<>(this.getClass(), userMessage)
);
```



##### 4.4.1.7、热门内容推荐

​		在内容展示的页面上，放置热门榜单，在业务上有着以下十分重要的价值：

​		1.提升用户粘性：热门榜单能够吸引用户的注意力，使他们更愿意停留在页面上浏览更多内容。

​		2.引导用户发现内容：热门榜单能够帮助用户快速发现最受欢迎、最值得关注的内容。

​		3.推动内容消费：热门榜单上的内容通常是点击率、观看量、分享量等指标较高的内容，这能够激发用户的好奇心和观看欲望。

​		4.促进内容创作者积极性：热门榜单对于内容创作者来说也是一种激励。

​		因此，本系统的课程广场、答疑广场、随笔广场均进行了热门内容推荐。其中，在课程广场展示了7日热门榜；在随笔广场展示了七天阅读排行、七天收藏排行、七天点赞排行。这些排行榜将有效提升用户使用体验。

![图4-12 7日热门榜前端样式](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\25.jpg)

​		由于排行榜的业务逻辑主要在后端，前端只负责样式展示，这里只介绍后端逻辑。

​		排行榜业务上的主要需求为，对于需要关注的指标（点赞量、浏览量等），记录每日的变化情况，在获取榜单时，统计过往时间段的计数总和，关键在于如何在尽可能高效的时间空间利用率下完成这一业务功能。本系统中，使用Redis中的ZSet进行实现。Redis中的ZSet是一个有序集合，通过指定一个score，根据score进行自然排序，同时，ZSet还支持一系列集合交并差运算，提供了十分强大的功能。

​		核心思想是，每天一条记录，用当天日期作为Key，score为对应指标值，value为内容Id，这样对于一条记录而言，可以获取当天每种指标下所有内容的计数情况，生成排行榜时，聚合前七天的记录，生成一个新的ZSet，这个ZSet便是我们所需要的排行榜，取出其中的内容id，返回数据即可。每日的数据记录集成到消费者服务中，因为计数功能本身是由消费者服务负责实现的。

​		核心代码如下：

```java
    /**
     * Redis中更新收藏记录
     *
     * @param blogId
     * @param blogType
     */
    private void addCollectRank(Long blogId, BlogTypeEnum blogType) {
        String redisKey = RedisPrefix.ARTICLE_COLLECT + blogType.getType() + ":" + DateUtils.dateTime();
        expireKey(redisKey);
        redisTemplate.opsForZSet().incrementScore(redisKey, blogId, 1D);
    }

    private void expireKey(String redisKey) {
        if (!Boolean.TRUE.equals(redisTemplate.hasKey(redisKey))) {
            redisTemplate.opsForZSet().add(redisKey, 0L, 0D);
            redisTemplate.expire(redisKey, 10, TimeUnit.DAYS);
        }
    }

    /**
     * 制作排行榜
     *
     * @param blogId
     * @param blogType
     */
    @Override
    public List<BlogRankVo> getRank(ArticleRankEnum rankEnum) {
        String rankPrefix = "";
        String recPrefix = "";

        switch (rankEnum) {
            case VIEW:
                rankPrefix = RedisPrefix.ARTICLE_VIEW_RANK;
                recPrefix = RedisPrefix.ARTICLE_VIEW;
                break;
            case LIKE:
                rankPrefix = RedisPrefix.ARTICLE_LIKE_RANK;
                recPrefix = RedisPrefix.ARTICLE_LIKE;
                break;
            case COLLECT:
                rankPrefix = RedisPrefix.ARTICLE_COLLECT_RANK;
                recPrefix = RedisPrefix.ARTICLE_COLLECT;
                break;
            default:
                // unreachable
                break;
        }

        String redisKey = rankPrefix + BlogTypeEnum.ARTICLE.getType() + ":" + DateUtils.dateTime();
        List<Long> idList;
        if (!Boolean.TRUE.equals(redisTemplate.hasKey(redisKey))) {
            // 如果不存在该key，制作排行榜
            buildRank(rankPrefix, recPrefix);
        }
        Set<ZSetOperations.TypedTuple<Long>> typedTuples = redisTemplate
                .opsForZSet().rangeWithScores(redisKey, RankConfig.ARTICLE_RANK_START, RankConfig.ARTICLE_RANK_END);

        if (CollectionUtils.isEmpty(typedTuples)) {
            return new ArrayList<>();
        }

        idList = typedTuples.stream().filter(t-> !Long.valueOf(0L).equals(t.getValue())).sorted((a, b) -> {
            Double aScore = a.getScore();
            Double bScore = b.getScore();
            if (aScore == null && bScore == null) {
                return 0;
            } else if (aScore== null || bScore == null) {
                return aScore == null ? 1 : -1;
            } else {
                return bScore.compareTo(aScore);
            }
        }).map(ZSetOperations.TypedTuple::getValue).collect(Collectors.toList());

        if (CollectionUtils.isEmpty(idList)) {
            return new ArrayList<>();
        }

        Map<Long, List<Blog>> blogMap = blogMapper.getBlogByIds(idList)
                .stream().collect(Collectors.groupingBy(Blog::getId));

        return idList.stream().map(id -> {
            BlogRankVo vo = new BlogRankVo();
            vo.setBlogId(id);
            vo.setTitle(blogMap.get(id).get(0).getTitle());
            return vo;
        }).collect(Collectors.toList());
```

​		





#### 4.4.2、内容与个人信息管理

##### 4.4.2.1、发布物管理

​		用户在发布物管理页面可以管理自己发布的随笔和问题，以分类多级展示。上方有标题、状态、分类等搜索条件，用户可以在这里选择对应的内容进行查看、修改或者删除。前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\40.jpg)

​		管理页面的查看修改可以复用之前的代码，这里不再赘述。列表查询的主要流程即为根据查询条件从数据库中查询原始数据，再组装数据为前端所需格式返回。后端核心代码如下：

```java
    @Override
    public List<ArticleQueryVo> getArticleList(ArticleQueryDto dto) {
        List<ArticleQueryVo> voList = new ArrayList<>();
        Long userId = SecurityUtils.getUserId();
        // 先查出随笔对象，再根据随笔对象查询出个人分类，组装返回
        Blog blog = new Blog();
        blog.setAuthorId(userId);
        blog.setTitle(dto.getTitle());
        blog.setStatus(dto.getStatus());
        blog.setArticleClassify(dto.getArticleClassification());
        blog.setPersonClassify(dto.getPersonClassification());
        blog.setType(BlogTypeEnum.ARTICLE.getType());

        List<Blog> blogList =
                blogMapper.getArticleList(blog, dto.getPageSize(), (dto.getPageNum() - 1) * dto.getPageSize(), null);
        if (CollectionUtils.isEmpty(blogList)) {
            return voList;
        }
        List<Long> personClassIdList = blogList
                .stream().map(Blog::getPersonClassify).distinct().collect(Collectors.toList());
        List<PersonalClassification> pClassList = blogMapper.getPersonClassByIds(personClassIdList);
        Map<Long, List<Blog>> groupByPClass = blogList
                .stream().collect(Collectors.groupingBy(Blog::getPersonClassify));

        // 组装数据
        voList = pClassList.stream().map(pc -> {
            ArticleQueryVo articleVo = new ArticleQueryVo();
            articleVo.setClassId(pc.getId());
            articleVo.setClassName(pc.getClassName());
            articleVo.setCreateTime(DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS, pc.getCreateTime()));

            List<Blog> bList = groupByPClass.get(pc.getId());

            List<ArticleQueryVo.ArticleQueryChild> children = new ArrayList<>();
            if (!CollectionUtils.isEmpty(bList)) {
                children = bList.stream().map(b -> {
                    ArticleQueryVo.ArticleQueryChild child = new ArticleQueryVo.ArticleQueryChild();
                    child.setArticleId(b.getId());
                    child.setTitle(b.getTitle());
                    child.setPreview(b.getPreview());
                    child.setStatus(b.getStatus());
                    child.setArticleClassify(b.getArticleClassify().toString());
                    child.setPublishTime(b.getReleaseTime());
                    child.setCreateTime(DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS, b.getCreateTime()));
                    child.setLikeCnt(b.getLikeCnt());
                    child.setCommentCnt(b.getCommentCnt());
                    child.setViewCnt(b.getViewCnt());
                    child.setCollectCnt(b.getCollectCnt());
                    return child;
                }).sorted((a, b) -> b.getCreateTime().compareTo(a.getCreateTime())).collect(Collectors.toList());
            }
            articleVo.setChildren(children);
            return articleVo;
        }).collect(Collectors.toList());

        // 设置id
        int cursor = 1;
        for (ArticleQueryVo queryVo : voList) {
            queryVo.setId(cursor++);
            List<ArticleQueryVo.ArticleQueryChild> children = queryVo.getChildren();
            if (!CollectionUtils.isEmpty(children)) {
                for (ArticleQueryVo.ArticleQueryChild child : children) {
                    child.setId(cursor++);
                }
            }
        }

        return voList;
    }
```



##### 4.4.2.2、收藏管理

​		用户在收藏管理页面可以查看自己所有收藏的内容，业务形态上相当于收藏夹的功能，用户可以在这里快速查看自己收藏过的内容。在所有内容浏览页面，用户点击收藏按钮后便会将该内容收藏，并可在该页面查看。收藏管理的前端样式如下图：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\41.jpg)

​		

​		收藏管理列表查询的后端核心代码如下：

```java
    @Override
    public ArticleCollectQueryVo collectList(ArticleCollectQueryDto dto) {
        ArticleCollectQueryVo vo = new ArticleCollectQueryVo();
        Long userId = SecurityUtils.getUserId();
        List<ArticleCollectQueryVoUnit> voUnitList = blogCollectedMapper.collectList(userId, dto, dto.getPageSize(), (dto.getPageNum() - 1) * dto.getPageSize());
        long total = blogCollectedMapper.getCollectedTotal(userId);
        // 获取作者昵称
        if (!CollectionUtils.isEmpty(voUnitList)) {
            List<Long> userIdList = voUnitList
                    .stream().map(ArticleCollectQueryVoUnit::getAuthorId)
                    .distinct().collect(Collectors.toList());
            R<List<SysUser>> infoByIds = remoteUserService.getInfoByIds(userIdList, SecurityConstants.INNER);
            List<SysUser> userList = infoByIds.getData();
            Map<Long, List<SysUser>> groupById = userList.stream().collect(Collectors.groupingBy(SysUser::getUserId));
            voUnitList.forEach(unit -> unit.setAuthorName(groupById.get(unit.getAuthorId()).get(0).getNickName()));
        }

        vo.setList(voUnitList);
        vo.setTotal(total);
        return vo;
    }
```



​		内容收藏的后端核心代码如下：

```java
    @Override
    public int collect(IdDto dto, BlogTypeEnum typeEnum) {
        Long articleId = dto.getId();
        Long userId = SecurityUtils.getUserId();
        BlogCollected blogCollected = new BlogCollected();
        blogCollected.setBlogId(articleId);
        blogCollected.setUserId(userId);

        int flag = blogCollectedMapper.insertBlogCollected(blogCollected);

        if (flag > 0) {
            // 通知下游改变收藏计数
            BlogMessage message = new BlogMessage();
            message.setMessageId(dto.getId());
            message.setBlogId(dto.getId());
            message.setBlogType(typeEnum.getType());
            message.setOperateType(OperateType.ADD.getType());
            message.setType(BlogMessage.MessageType.COLLECT.getType());
            rocketmqTemplate.asyncSendOrderly(
                    MqTopicConstants.BLOG_TOPIC,
                    message,
                    String.valueOf(message.getMessageId()),
                    new DefaultCallBack<>(this.getClass(), message)
            );

        }

        return flag;
    }
```





##### 4.4.2.3、关注和粉丝管理

​		关注功能是系统社交功能的一个核心步骤。用户可以在内容浏览页面找到对应的作者关注按钮点击关注，或者进入对应的用户主页关注。关注后用户就成了对应被关注者的粉丝。用户关注了别的用户后，当别的用户发布新内容时，会第一时间获取系统站内站外通知。用户关注和粉丝管理前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\42.jpg)

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\43.jpg)

​		

​		后端通过一张关注关系表记录用户关注信息，用户关注和列表查询的核心代码如下所示：

```java
    @Override
    public int follow(FollowDto dto) {
        Long followId = dto.getFollowId();
        Long userId = SecurityUtils.getUserId();
        OperateType typeEnum = OperateType.getEnum(dto.getOperateType());
        if (followId.equals(userId)) {
            throw new ServiceException("不可以关注自己！");
        }

        int flag = 0;
        switch (typeEnum) {
            case ADD:
                flag = followListMapper.addFollowList(userId, followId);
                if (flag > 0) {
                    bizUserMapper.increaseSubCnt(userId);
                }
                break;
            case CANCEL:
                flag = followListMapper.delFollowList(userId, followId);
                if (flag > 0) {
                    bizUserMapper.decreaseSubCnt(userId);
                }
                break;
            default:
                // unreachable
                break;
        }


        if (flag > 0) {
            // 发布消息更新用户粉丝数量
            UserMessage message = new UserMessage();
            message.setMessageId(dto.getFollowId());
            message.setUserId(dto.getFollowId());
            message.setOperateType(typeEnum.getType());
            message.setType(UserMessage.MessageType.FOLLOW.getType());
            rocketmqTemplate.asyncSendOrderly(
                    MqTopicConstants.USER_TOPIC,
                    message,
                    String.valueOf(message.getMessageId()),
                    new DefaultCallBack<>(this.getClass(), message)
            );
        }
        return flag;
    }

    @Override
    public BizUser getBizUser(IdDto dto) {
        return bizUserMapper.getById(dto.getId());
    }

    @Override
    public Boolean isFollowed(IdDto dto) {
        Long userId = SecurityUtils.getUserId();
        int flag = followListMapper.isFollowed(userId, dto.getId());
        return flag > 0;
    }

    @Override
    public List<UserBasicInfoVo> getFollowList(ListDto dto) {
        // 获取粉丝列表
        Long userId = SecurityUtils.getUserId();
        List<Long> idList = followListMapper.getFollowerIdList(
                userId,
                dto.getPageSize(),
                SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize()));

        if (CollectionUtils.isEmpty(idList)) {
            return new ArrayList<>();
        }
        return packUserBasicInfoVoList(userId, idList);
    }

    @Override
    public List<UserBasicInfoVo> getSubList(ListDto dto) {
        // 获取关注列表
        Long userId = SecurityUtils.getUserId();
        List<Long> idList = followListMapper.getSubIdList(
                userId,
                dto.getPageSize(),
                SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize())
        );

        if (CollectionUtils.isEmpty(idList)) {
            return new ArrayList<>();
        }
        return packUserBasicInfoVoList(userId, idList);
    }
```







##### 4.4.2.4、用户基本信息维护

​	**（1）登录、注册和访问鉴权**

​		SSO单点登录是指用户只需登录一次，就能访问同一系统下的所有其他服务，其原理是使用一个单一的登录认证服务，所有其它服务都通过这个服务进行权限验证。每次访问其它服务时，会调用认证中心的服务接口判断权限。

​		为了用户密码的安全性，系统采用MD5对用户密码加密。通过将密码转换成byte数组并进行Hash计算，之后将Hash值转换为十六进制字符串并返回。MD5加密核心伪代码为：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\10.jpg)



MD5加密后效果图如 4-6 所示

![图 4-6 加密效果图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\11.jpg)

​	

​		完成注册后，系统通过引入JWT库实现JWT用户登录，首先拦截前端入参中的用户Id和密码并进行验证，验证通过后使用createJwt()方法创建一个JWT令牌存入Redis中。在createJWT()方法中，首先生成JWT的过期时间，然后创建一个Claims对象，用于存储JWT的Payload。我们设置了Payload的Subject为用户名。接下来，我们设置了JWT的签名算法和密钥，并使用Jwts.builder()方法创建了一个JWT并返回。生成JWT的核心伪代码：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\12.jpg)



基于JWT的用户单点登录时序图如图 4-7 所示。

![图 4-7 JWT单点登录时序图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\13.jpg)



​		**（2）个人信息主页**

​		个人信息主页展示个人基本信息，例如用户名、粉丝数、点赞数、关注数等。还展示个人发布的想法和随笔，本账号用户进入自己的个人主页还可以修改个人信息和密码。个人信息主页前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\39.jpg)

​		

​		后端查询用户信息核心代码如下：

```java
    @Override
    public UserBasicInfoVo getBasicInfo(IdDto dto) {
        Long userId = dto.getId();
        SysUser sysUser = userMapper.selectUserById(userId);
        BizUser bizUser = bizUserMapper.getById(userId);
        Boolean followed = userFollowService.isFollowed(dto);

        UserBasicInfoVo vo = new UserBasicInfoVo();
        vo.setId(userId);
        vo.setAvatar(sysUser.getAvatar());
        vo.setNickName(sysUser.getNickName());
        vo.setEmail(sysUser.getEmail());
        vo.setPhonenumber(sysUser.getPhonenumber());
        vo.setSex(sysUser.getSex());
        vo.setFollowed(followed);
        vo.setLikeCnt(bizUser.getLikeCnt());
        vo.setFollowerCnt(bizUser.getFollowerCnt());
        vo.setSubCnt(bizUser.getSubCnt());
        vo.setCreateTime(DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS, sysUser.getCreateTime()));

        return vo;
    }
```







#### 4.4.3、系统通知与私信

​		系统通知和站内私信对于在线社区有很重要的意义，例如提升用户互动与活跃度、促进业务转化和增长以及提高用户满意度和忠诚度等。



##### 4.4.3.1、用户站内私信

​		用户在个人中心-个人私信页面可以查看最近的联系人和私信聊天窗。联系人的定义是最近的发送过消息的人，当两个人之间产生私信，两者就会自动成为联系人。个人私信前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\44.jpg)

​		除了在个人私信页面和用户私信外，在其他内容展示页面有用户头像的地方，可以通过鼠标悬停在头像上方的用户信息栏进入私信，样式图如下：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\45.jpg)

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\46.jpg)

​	

​		私信功能由通知微服务notify-service负责，后端主要包含两张数据表：contact_book和text_message，前者用来记录用户的联系人信息，后者记录私信信息。获取用户联系人的后端核心代码如下：

```java
    @Override
    public List<ContactListVo> contactList(ListDto dto) {
        Long userId = SecurityUtils.getUserId();
        ContactBook contactBook = new ContactBook();
        contactBook.setUserId(userId);

        List<ContactBook> contactBookList = contactBookMapper.selectContactList(
                contactBook,
                dto.getPageSize(),
                SqlUtil.getOffset(dto.getPageNum(), dto.getPageSize()));

        if (CollectionUtils.isEmpty(contactBookList)) {
            return new ArrayList<>();
        }

        List<Long> contactIdList = contactBookList.stream().map(ContactBook::getContactId).collect(Collectors.toList());
        List<SysUser> userList = remoteUserService.getInfoByIds(contactIdList, SecurityConstants.INNER).getData();
        Map<Long, List<SysUser>> groupById = userList.stream().collect(Collectors.groupingBy(SysUser::getUserId));

        // 查询与每一个联系人的未读消息数
        List<UnReadCnt> unReadCntList = textMessageMapper.selectUnReadCnt(userId, contactIdList);
        Map<Long, List<UnReadCnt>> unReadCntMap = unReadCntList.stream().collect(Collectors.groupingBy(UnReadCnt::getSenderId));

        // 查询与每个联系人最新一条消息的前15个字
        Map<Long, List<ContactBook>> contactGroupById = contactBookList
                .stream().collect(Collectors.groupingBy(ContactBook::getContactId));

        return contactBookList.stream().map(book -> {
            SysUser sysUser = groupById.get(book.getContactId()).get(0);
            List<UnReadCnt> unReadCnts = unReadCntMap.get(book.getContactId());
            Long unreadCnt = CollectionUtils.isEmpty(unReadCnts) ? 0L : unReadCnts.get(0).getUnreadCnt();
            String msgPreview = contactGroupById.get(book.getContactId()).get(0).getMsgPreview();
            ContactListVo vo = new ContactListVo();
            vo.setContactId(sysUser.getUserId());
            vo.setContactName(sysUser.getNickName());
            vo.setAvatar(sysUser.getAvatar());
            vo.setUnReadCnt(unreadCnt);
            vo.setLatestMsgPreview(msgPreview);

            return vo;
        }).collect(Collectors.toList());

    }
```



​		用户发送私信的核心代码如下：

```java
    @Override
    public long send(SendDto dto) {
        Long senderId = SecurityUtils.getUserId();
        return doSend(dto.getContent(), senderId, dto.getReceiverId());
    }

    private Long doSend(String content, Long senderId, Long receiverId) {
        TextMessage message = new TextMessage();
        message.setSenderId(senderId);
        message.setReceiverId(receiverId);
        message.setContent(content);

        int flag = textMessageMapper.insertMessage(message);

        if (flag > 0) {
            flag = getAndUpdateContact(receiverId, senderId, content);
            if (flag > 0) {
                getAndUpdateContact(senderId, receiverId, content);
            }
        }

        return message.getId();
    }
```





##### 4.4.3.2、站内系统通知

​		系统站内通知基于用户的关注功能。通知的对象为：关注了自己的用户、回复评论的评论发布者、回答问题的问题发布者；触发站内系统通知的动作为：发布评论、回答问题、发布想法、随笔、问题、课程。站内通知基于私信功能，当触发了站内通知功能时，系统会通过私信的方式由系统通知向用户发送一条私信，提示其相关的内容。

​		站内通知由通知微服务notify-service负责实现，对外提供一个系统间接口，触发动作的业务调用方调用这个系统间接口进行实现。后端核心代码实现如下：

```java
    @Override
    public long systemNotifyBatch(SysNotifyDto dto) {
        List<Long> userIds = dto.getUserIds();
        String content = dto.getContent();
        if (StringUtils.isEmpty(content) || CollectionUtils.isEmpty(userIds)) {
            return 0;
        }

        userIds.forEach(receiverId -> doSend(content, 1L, receiverId));

        return 1;
    }
    
        private Long doSend(String content, Long senderId, Long receiverId) {
        TextMessage message = new TextMessage();
        message.setSenderId(senderId);
        message.setReceiverId(receiverId);
        message.setContent(content);

        int flag = textMessageMapper.insertMessage(message);

        if (flag > 0) {
            flag = getAndUpdateContact(receiverId, senderId, content);
            if (flag > 0) {
                getAndUpdateContact(senderId, receiverId, content);
            }
        }

        return message.getId();
    }
```



​		前端样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\47.jpg)







##### 4.4.3.3、站外邮箱通知

​		站外通知采用电子邮件的方式，当触发通知动作时，系统邮箱会往用户在个人信息中维护的电子邮箱中投送一条电子邮件，以达到站外通知的效果，基于SMTP协议实现。

​		首先，在系统中引入SMTP相关POM依赖：

```xml
            <!--发送邮件依赖-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-mail</artifactId>
                <version>1.5.7.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>com.sun.mail</groupId>
                <artifactId>javax.mail</artifactId>
                <version>1.5.6</version>
            </dependency>
```

​	

​		编写工具类MailService，为业务提供发送邮件的能力，接口定义如下：

```java
public interface MailService {

    /**
     * 向关注者发送系统通知
     * @param subject
     * @param content
     */
    void systemNotifyToFollowers(String subject, String content);

    /**
     * 系统通知，同时进行站内通知和站外通知
     * @param userIds
     * @param subject
     * @param content
     */
    void systemNotify(List<Long> userIds, String subject, String content);

    /**
     * 发送普通文本邮件
     * @param to 收件人
     * @param subject 主题
     * @param content 内容
     */
    void sendSimpleMail(String to, String subject, String content);

    /**
     * 发送HTML邮件
     * @param to 收件人
     * @param subject 主题
     * @param content 内容（可以包含<html>等标签）
     */
    void sendHtmlMail(String to, String subject, String content);

    /**
     * 发送带附件的邮件
     * @param to 收件人
     * @param subject 主题
     * @param content 内容
     * @param filePath 附件路径
     */
    void sendAttachmentsMail(String to, String subject, String content, String filePath);

    /**
     * 发送带图片的邮件
     * @param to 收件人
     * @param subject 主题
     * @param content 文本
     * @param rscPath 图片路径
     * @param rscId 图片ID，用于在<img>标签中使用，从而显示图片
     */
    void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId);

}
```



​		引入依赖后，需要在系统配置文件中配置发送邮件相关信息，Nacos中对应的配置如下：

```yaml
# spring配置
spring:
  mail:
    #QQ邮箱配置
    port: 465
    host: smtp.qq.com  #QQ邮箱服务器
    username: 1980817350@qq.com  #发送者QQ邮箱
    password: wlodomxarqxqebjc  #发送者QQ邮箱第三方授权码
    default-encoding: UTF-8  #邮件编码类型
    properties:
      mail:
        timeout:
        smtp:
          auth: true
          ssl:
            enable: true
          starttls:
            enable: true
            required: true
```



​		接着只需要在业务逻辑中需要发送站外通知的部分调用相关方法即可，其中一个示例如下：

```java
            // 向关注者发送系统通知
            String nickName = remoteUserService.
                    getUserBasicInfoByIds(Collections.singletonList(userId), SecurityConstants.INNER)
                    .getData().get(0).getNickName();
            mailService.systemNotifyToFollowers(
                    "您关注的用户发布了一个新的课程！",
                    "您关注的用户 " + nickName + " 发布了新的课程：" + course.getTitle() + " ，赶快上线学习吧！"
            );
```





#### 4.4.4、三方API开放

​		系统向认证过的开发者开放第三方API调用，具有促进开发者生态的繁荣、提高系统的灵活性和可拓展性、提升用户体验和促进业务模式的创新等重要作用，是系统的一个重要功能和业务组成部分。



##### 4.4.4.1、三方开发接入鉴权

​		三方开发者放权由系统管理员执行，管理员在开发者认证页面，通过手机号码等级第三方开发者，随后会生成一对唯一的AppSecretId和AppSecretKey，随后需要用户手动保存这两个认证值，系统不会再以任何形式展示生成后的值。第三方接口调用时，首先通过在请求中携带AppSecretId和AppSecretKey调用认证接口，生成一个访问的AccessToken，该令牌在一段时间内生效。随后的请求中携带这个令牌，便可以调用系统接口。系统的认证中心会判断用户权限，有效则生成AccessToken。流程图如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\49.jpg)









##### 4.4.4.2、接口文档提供

​		为了使开发者可以更好地接入系统，提供标准详细的接口文档意义重大。接口文档的作用主要在于：提供清晰的使用指南；促进开发者理解和上手；减少沟通的成本和误解；保证API的一致性和稳定性；方便测试和维护；增强API的可信度和吸引力。本系统的接口文档通过接入Swagger进行统一实现。

​		Swagger是一个规范和完整的框架，主要用于生成、描述、调用和可视化RESTful风格的Web服务。Swagger通过注解或配置文件的方式，从源代码中自动生成接口文档，包括接口名称、描述、请求参数、响应数据等信息，并提供了一个直观的、可交互的接口文档界面，方便用户查看和测试接口。

​		首先，在系统中引入Swagger的依赖配置：

```xml
            <!-- Swagger 依赖配置 -->
            <dependency>
                <groupId>io.swagger</groupId>
                <artifactId>swagger-models</artifactId>
                <version>${swagger.core.version}</version>
            </dependency>
            <dependency>
                <groupId>io.swagger</groupId>
                <artifactId>swagger-annotations</artifactId>
                <version>${swagger.core.version}</version>
            </dependency>
```

​	

​		在需要使用swagger生成接口文档的服务类启动入口，增加@EnableCustomSwagger2注解，实例代码如下：

```java
@EnableCustomConfig
@EnableCustomSwagger2
@EnableRyFeignClients
@SpringBootApplication
public class NotifyApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotifyApplication.class, args);
        System.out.println("(♥◠‿◠)ﾉﾞ  通知服务模块启动成功   ლ(´ڡ`ლ)ﾞ");
    }
}
```



​		在配置中增加swagger相关配置项：

```yaml
# swagger配置
swagger:
  title: 系统模块接口文档
  license: Powered By EduVerse
  licenseUrl: https://eduVerse.vip
```

​	

​		认证过的用户可以在页面的系统工具-系统接口菜单进入，查看到详细的接口文档，样式如下图所示：

![](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\48.jpg)





## 第5章、 系统测试

​		系统测试包括功能性测试和非功能性测试。本章将从社区系统的各个服务模块，对比需求分析和系统设计，对主要的核心功能进行测试：对系统不同服务之间的通信链路进行完整性测试；从每秒处理的请求量、响应时间、请求成功率等方面，进行系统的性能测试。



### 5.1、系统测试环境

​		测试环境是软件、硬件、网络、数据集合、测试工具的集合。良好的测试环境能让开发人员更好地对系统进行测试，减少环境的变动对测试产生的不良影响。测试环境应满足真实的场景需求，这样测试效果才是最好的。Docker容器作为主要的测试载体，组件的运行和项目部署都是在Docker容器中。系统测试工具版本及环境参数如表5-1所示。

| 测试环境          | 具体环境参数        |
| ----------------- | ------------------- |
| Docker容器        | Docker-ce-18.09.9   |
| 服务器系统        | CentOS 7.6          |
| JDK镜像           | jdk 1.8             |
| Redis镜像         | redis 5.0.7         |
| MySQL镜像         | mysql 8.0           |
| ElasticSearch镜像 | elasticsearch:7.4.2 |
| RocketMQ镜像      | RocketMQ 2.0.2      |



### 5.2、系统功能测试

​		系统功能测试包括在对系统搭建微服务加购以后，用户启动系统之后，对系统中所有的功能进行观察和使用的检测。



#### 5.2.1、内容发布和交互测试

​		系统内容发布和交互相关功能测试，结果如表5-2所示。

| 编号 | 测试目标             | 前置条件         | 测试操作             | 测试预期目标                                       | 测试结果     |
| ---- | -------------------- | ---------------- | -------------------- | -------------------------------------------------- | ------------ |
| B1   | 用户能否正常注册     | 进入注册页面     | 输入注册的账号的密码 | 输入正常账号会注册成功；输入已存在的账号会注册失败 | 符合测试要求 |
| B2   | 用户能否正常登录     | 进入登录页       | 输入账号和密码       | 密码正确登录成功；密码错误登录失败                 | 符合测试要求 |
| B3   | 能否搜索内容         | 输入搜索条件     | 输入标题；选择分类   | 显示搜索结果；若搜索不到则返回空                   | 符合测试要求 |
| B4   | 能否点赞、收藏内容   | 进入内容查看页面 | 点击点赞、收藏按钮   | 可以点赞和收藏成功                                 | 符合测试要求 |
| B5   | 能否发布内容         | 进入内容发布页面 | 输入需要发布的内容   | 发布成功                                           | 符合测试要求 |
| B6   | 能够进行评论         | 进入评论页       | 评论操作             | 可以评论成功                                       | 符合测试要求 |
| B7   | 能否看到评论         | 进入评论列表     | 查看评论             | 可以看到评论结果                                   | 符合测试要求 |
| B8   | 能否访问内容管理页面 | 进入内容管理页面 | 查看内容管理         | 可以看到内容管理页面                               | 符合测试要求 |
| B9   | 能否查看热门排行榜   | 进入内容展示页面 | 查看热门排行榜       | 可以正确查看到热门排行榜                           | 符合测试要求 |



#### 5.2.2、用户交互与系统通知测试

​		系统用户交互和通知相关功能测试，结果如表5-3所示。

| 编号 | 测试目标                                         | 前置条件                               | 测试操作                             | 测试预期目标                                                 | 测试结果     |
| ---- | ------------------------------------------------ | -------------------------------------- | ------------------------------------ | ------------------------------------------------------------ | ------------ |
| N1   | 能否和其他用户私信                               | 进入私信页面                           | 向其他用户发送私信                   | 双方用户都可以正常收到信息                                   | 符合测试要求 |
| N2   | 能否查看自己的关注列表                           | 进入关注管理页面                       | 查看关注列表                         | 可以正确查看到自己的关注列表                                 | 符合测试要求 |
| N3   | 能否查看自己的粉丝列表                           | 进入查看粉丝列表页面                   | 查看粉丝列表                         | 可以正确查看到粉丝列表                                       | 符合测试要求 |
| N4   | 能否正确展示自己和其他人的主页信息               | 进入用户主页                           | 查看主页信息                         | 用户信息是否展示正确，是否可以查看到用户发布的想法和随笔     | 符合测试要求 |
| N5   | 能否关注用户                                     | 进入含有用户关注按钮的页面             | 点击用户关注按钮                     | 可以关注成功，关注后用户出现在自己的关注列表，自己出现在用户的粉丝列表 | 符合测试要求 |
| N6   | 关注的问题得到回答后，是否可以收到站内系统通知   | 关注问题，并且关注的问题被回答         | 关注一个问题，再去回答这个问题       | 关注者收到一条站内系统通知，通知其内容得到回答               | 符合测试要求 |
| N7   | 关注的用户发布新内容时，是否可以收到站内系统通知 | 关注用户，并且被关注的用户发布了新内容 | 关注一个用户，再使用用户账号发布内容 | 关注者收到对应的站内系统私信通知                             | 符合测试要求 |
| N8   | 关注的问题得到回答后，是否可以收到系统站外通知   | 关注问题，并且关注的问题被回答         | 关注一个问题，再去回答这个问题       | 关注者个人信息设置的邮箱收到一条系统邮件通知                 | 符合测试要求 |
| N9   | 关注的用户发布新内容时，是否可以收到系统站外通知 | 关注用户，并且被关注的用户发布了新内容 | 关注一个用户，再使用用户账号发布内容 | 关注者个人信息设置的邮箱收到一条系统邮件通知                 | 符合测试要求 |



### 5.3、系统非功能测试

​		功能测试保证了系统的使用需求，用户可以很方便地使用这个平台。除此之外，系统也需要进行非功能测试，即性能测试，系统的性能测试可以有效验证系统是否达到预期使用目标，性能是对系统使用牢靠性的重要保证。

​		为了测试系统使用的性能状况，使用Jmeter工具进行性能测试，现在以用户访问系统为例，输入100个用户访问，参数状态如图所示。在Jmeter的配置中，添加端口号为127.0.0.1，端口为8091。其中测试使用的本机电脑，电脑配置为：Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz。

![图5-1 访问测试参数配置图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\26.jpg)

​		

​		参数配置完成以后，选择聚合结果数、聚合报告等选项，观察测试报告的结果。如图所示，100个用户同时访问系统平台界面时，平均响应时间是2.35秒，最大的响应时间3.23秒，最小的响应时间是0.8秒，错误率为0%。

![图5-2 访问测试性能状态图](C:\Users\生产者\Desktop\毕设\借鉴文献\正文图片\27.jpg)

​		

​		针对系统可能出现的瓶颈问题，也进行了测试。表 5-4主要从系统点击的平均响应时间、并发访问状态、开启系统多个服务时CPU的使用率、内存使用具以及系统卡顿情况做了测试状态记录。

| 测试目标     | 预期值      | 实际值      | 是否符合要求 |
| ------------ | ----------- | ----------- | ------------ |
| 平均响应时间 | 3s以内/单击 | 1s左右/单击 | 是           |
| 并发数       | >50         | 100         | 是           |
| CPU使用率    | <50%        | 25%-50%     | 是           |
| 内存使用率   | <50%        | 40%左右     | 是           |
| 卡顿率       | <3%         | 0.5%        | 是           |



## 第6章、 总结与展望

​		随着信息技术的飞速发展，在线教育已逐渐成为教育领域的重要组成部分。为了满足用户对在线教育服务的需求，本论文基于Spring Cloud搭建了一个分布式微服务在线教育社区开放API平台。通过深入研究Spring Cloud框架的核心组件，我们成功地将各个服务模块进行解耦，实现了服务的独立部署和动态扩展。

​		在平台的设计和实现过程中，我们首先对在线教育社区的业务需求进行了详细分析，确定了平台的功能模块和架构设计。然后，利用Nacos的服务注册与发现机制，实现了服务的自动注册和发现，确保了服务的可靠通信。同时，通过RocketMQ消息队列异步通信和Feign声明式服务调用，我们提高了系统的可用性和性能。

​		通过实际运行和测试，我们验证了基于Spring Cloud搭建的分布式微服务在线教育社区开放API平台的稳定性和可靠性。平台能够为用户提供丰富的在线教育服务，包括内容发布与管理、系统通知和站内外私信、用户私信等功能。同时，平台还提供了开放API接口，方便第三方开发者进行集成和扩展。

​		然而，尽管我们已经取得了一定的成果，但仍然存在一些不足之处。例如，在前端页面UI样式的设计上还可以进一步提升，提供更加用户交互友好，美观大方的页面样式。未来，我们将继续深入研究分布式微服务的相关技术，探索更多的优化手段和安全策略，以提高平台的整体性能和安全性。

​		展望未来，我们计划进一步完善平台的功能模块，增加更多的在线教育服务，如在线考试、智能推荐等。同时，我们还将加强与第三方开发者的合作，共同推动在线教育社区的发展和创新。





## 第7章、致谢

​		在本篇论文即将完成之际，我谨向所有在本科毕业设计过程中给予我无私帮助和支持的人表示衷心的感谢。

​		首先，我要特别感谢我的指导老师刘豫钧老师。刘豫钧老师在本科期间一直给予我悉心的指导和关心。在毕业设计的过程中，从选题到论文框架的构建，再到论文的撰写和修改，刘豫钧老师都倾注了大量的心血和精力。他深厚的专业知识以及耐心的指导，使我在论文写作上取得了长足的进步。

​		其次，我要感谢教育科学与技术学院的各位领导和老师们。在本科四年的学习生活中，他们为我提供了良好的学习环境和丰富的学术资源，使我在专业知识和技能上得到了全面的提升。同时，他们的教诲和关怀也让我在人生道路上更加坚定和自信。

​		此外，我还要感谢我的同学们和朋友们。在毕业设计的过程中，我们互相学习、互相帮助、共同进步。他们的陪伴和支持让我在遇到困难时能够坚持不懈，最终顺利完成毕业设计。

​		最后，我要感谢我的家人。他们一直是我最坚强的后盾，给予我无尽的关爱和支持。他们的鼓励和信任让我在学术道路上勇往直前，不断追求更高的目标。

​		再次感谢所有在我本科毕业设计过程中给予帮助和支持的人。我将永远铭记你们的恩情，并以此为动力，继续努力学习和工作，为社会做出更大的贡献。


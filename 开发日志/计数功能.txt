引入 RocketMQ 进行 浏览、点赞、评论、收藏 等 业务功能的计数功能

计数功能显然存在并发问题，然而我觉得简单地使用分布式锁处理并不优雅，因此打算使用mq实现，从流程上消除并发，并且保持良好的拓展性

以随笔点赞举例，核心思想是，对于一篇随笔的所有点赞请求，统一交到一个固定的 consumer 处理，由这个consumer不断负责数据表字段的更新

使用 RocketMQ 的分区顺序消息模型

                                                     ------topic-----
                                       ---hash--->  |     queue1     |  ---接收---> consumer1
producer ---携带--->  orderId(hashKey)  ---hash--->  |     queue2     |  ---接收---> consumer2
                                       ---hash--->  |     queue3     |  ---接收---> consumer3
                                                     -----------------

后续若需要拓展，增加topic下的queue和对应的consumer即可（保持队列数量大于等于消费者数量）

关于 RocketMQ 的消费模式和消息模式

消费模式 consumeMode，定义消费者消费消息的方法
    分为两种，CONCURRENTLY 和 ORDERLY
    前者是并发消费，后者是有序消费，默认并发
    简单理解，前者是一个消息还没有消费完就再消费另外一个消息，通过 consumeThreadMax 指定最大线程数，就是开多线程一次消费多个消息
    后者是一个消费完了才可以消费另外一个
    在当前场景下选择有序消费

消息模式 messageModel，定义消息的传播模式
    分为两种，BROADCASTING 和 CLUSTERING
    前者是广播，后者是负载均衡，默认是后者
    广播即所有订阅主题的消费者可以获取主题下所有队列的消息，负载均衡是消费者平分队列，每个消费者消费自己分到的队列的消息
    极端的性能情况下，创建更多的队列，保持队列和消费者为1:1，让每一个消费者只消费一个队列，可以获得最好的性能
    在当前场景下选择负载均衡模式

注意，关于负载均衡，需要考虑到RocketMQ服务端的版本，4.x 和 3.x 都是只支持队列级别的负载均衡的，更新的版本则支持消息级别负载均衡（参考官方文档），
本项目使用的版本是 4.4

同时消费者也有不同类型，分为PushConsumer、PullConsumer、SimpleConsumer
    PushConsumer：服务端将消息推给消费者，高度封装，默认这种消费者类型
    PullConsumer：消费者定期请求服务端，自己发现消息，一般不推荐使用（文档里说的）
    SimpleConsumer：可以更细致地定制开发，消息的获取、消费状态提交以及消费重试都是在消费者客户端自主进行的，实际上也是一种PullConsumer


同一消费者组下多个消费者的代码示例，参考：com.ruoyi.mqConsumers.consumers.blog_comment.CommentConsumer_1


//TODO 后续待优化点：
    关于是否点赞过（收藏过、浏览过）等的判断后续可以考虑使用bitmap优化，而不是当前的关系表；
    此外，计数的异步落库也可以进行优化，可以批量进行写入以减少字段自增的IO操作，可以有两个指标：
        对于一个消费者，首先，如果连续来了N个同一博客的自增消息，这些消息可以统一消费，一次性写到数据库中
        既然统一消费，就会有等待时间，如果连续消息数没有达到N，设置时间阈值，等待了这么久之后也进行落库
        总结：在三种情况下落库：
            1.连续来了N个消息
            2.来了一个不连续消息
            3.等待了一定时间还是没有收到下一个消息
    具体的实现方法，可以对消费者做代理，让所谓的消费者起到分拣器的作用，交由另外的组件落库




